{"componentChunkName":"component---src-templates-docs-js","path":"/part11/part11-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Exceptions\",\n  \"nav_order\": 112,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"exceptions\"\n  }, \"Exceptions\"), mdx(\"p\", null, \"When program execution ends with an error, an exception is thrown. For example a program might have called a method with null reference and the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NullReferenceException\"), \" gets thrown, or the program might try to refer to an element outside an array and it leads to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentOutOfRangeException\"), \" and so on.\"), mdx(\"p\", null, \"Some exceptions we have to always prepare for, such as errors when reading from a file or errors related to problems with a network connection. Runtime exceptions, such as the NullReferenceException, we do not have to prepare for beforehand. C# will always let you know if your code has a statement or an expression which can throw an error you have to prepare for.\"), mdx(\"h2\", {\n    \"id\": \"handling-exceptions\"\n  }, \"Handling exceptions\"), mdx(\"p\", null, \"We use \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"try {} catch (Exception e) {}\"), \" block structure to handle exceptions. Keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"try\"), \" starts a block containing the code which \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"might\"), \" throw an exception. What happens if an exception is thrown in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"try\"), \" block is defined in the block starting with the keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"catch\"), \". The keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"catch\"), \" is followed by the type of the exception handled by that block, for example \\\"all exceptions\\\" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"catch (Exception e)\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"try \\n{\\n  // code which possibly throws an exception\\n} catch (Exception e) \\n{\\n  // code block executed if an exception is thrown\\n}\\n\")), mdx(\"p\", null, \"We use the keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"catch\"), \" because causing an exception is referred to as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"throw\"), \"ing an exception.\"), mdx(\"p\", null, \"As mentioned above, we do not have to prepare for runtime exceptions such as the NullReferenceException. We do not have to handle these kinds of exceptions, so the program execution stops if an error causes the exception to be thrown. Next we will look at one such situation, parsing strings to integers.\"), mdx(\"p\", null, \"We have used the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Convert.ToInt32\"), \" method before. The method throws \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FormatException\"), \" if the string it has been given cannot be parsed into an integer.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Console.WriteLine(\\\"Give a number:\\\");\\nint number = Convert.ToInt32(Console.ReadLine());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Give a number:\\n> hotPotato\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\n   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\n   at System.Number.ParseInt32(ReadOnlySpan`1 value, NumberStyles styles, NumberFormatInfo info)\\n   at System.Convert.ToInt32(String value)\\n   at Exercise001.Program.Main(String[] args) in [. . .]]/Program.cs:line 12\\n\")), mdx(\"p\", null, \"The above program throws an error if the user input is not a valid number. The exception will cause the program execution to stop.\"), mdx(\"p\", null, \"Let's handle the exception. We wrap the call which might throw an exception into a try block, and the code executed if the exception is thrown into a catch block.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Console.WriteLine(\\\"Give a number:\\\");\\nint number = 0;\\ntry\\n{\\n  number = Convert.ToInt32(Console.ReadLine());\\n}\\ncatch (Exception e)\\n{\\n  Console.WriteLine(e.Message);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Give a number:\\n> potato\\nInput string was not in a correct format.\\n\")), mdx(\"p\", null, \"As you can see, we also used a property from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Exception\"), \". All the exceptions have a message, and it can be used with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"exception.Message\"), \". Try and find the message part from the exception we had not caught above.\"), mdx(\"p\", null, \"The code in the catch block is executed immediately if the code in the try block throws an exception. We can demonstrate this by adding a print statement below the line calling the Convert.ToInt32 method in the try block.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Console.WriteLine(\\\"Give a number:\\\");\\nint number = 0;\\ntry\\n{\\n  number = Convert.ToInt32(Console.ReadLine());\\n  Console.WriteLine(\\\"Good job!\\\");\\n}\\ncatch (Exception e)\\n{\\n  Console.WriteLine(e.Message);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Give a number:\\n> 12\\nGood job!\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Give a number:\\n> potato\\nInput string was not in a correct format.\\n\")), mdx(\"p\", null, \"User input, string \\\"potato\\\", is given to the Convert.ToInt32 method as a parameter. The method throws an error if the string cannot be parsed into an integer. Note, that the code within the catch block is executed only if an exception is thrown.\"), mdx(\"p\", null, \"Let's make our integer parser a bit more useful. We'll turn it into a method which prompts the user for a number until they give a valid number. The execution stops only when the user gives a valid number.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n  {\\n    ReadNumber();\\n  }\\n\\npublic static int ReadNumber()\\n{\\n  while (true)\\n  {\\n    Console.Write(\\\"Give a number: \\\");\\n    try\\n    {\\n      int readNumber = Convert.ToInt32(Console.ReadLine());\\n      return readNumber;\\n    }\\n    catch (Exception e)\\n    {\\n      Console.WriteLine(e.Message);\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Give a number: hotPotato\\nInput string was not in a correct format.\\nGive a number: Normal potato\\nInput string was not in a correct format.\\nGive a number: Spicy potato\\nInput string was not in a correct format.\\nGive a number: 12\\n\")), mdx(\"h2\", {\n    \"id\": \"catching-file-exceptions\"\n  }, \"Catching file exceptions\"), mdx(\"p\", null, \"A common usage of try-catch is with reading and writing files. For now, we have trusted our coding, and the filepaths we write to be correct. But what happens if the file does not exist? Let's take a look. Below is an example, we've already used.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string text = File.ReadAllText(\\\"fileDoesNotExist.txt\\\");\\nConsole.WriteLine(text);\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"In the examples below, [. . .] is used to hide the full path of the file. In the real exceptions, there would be a complete file path.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Unhandled exception. System.IO.FileNotFoundException: Could not find file '[. . .]/fileDoesNotExist.txt'.\\nFile name: '[. . .]/fileDoesNotExist.txt'\\n   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)\\n   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode)\\n   at System.IO.FileStream.OpenHandle(FileMode mode, FileShare share, FileOptions options)\\n   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options)\\n   at System.IO.StreamReader.ValidateArgsAndOpenPath(String path, Encoding encoding, Int32 bufferSize)\\n   at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks)\\n   at System.IO.File.InternalReadAllText(String path, Encoding encoding)\\n   at System.IO.File.ReadAllText(String path)\\n   at Exercise001.Program.Main(String[] args) in [. . .]/Program.cs:line 12\\n\")), mdx(\"p\", null, \"We get quite a stack trace, but most importanty, we get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FileNotFoundException\"), \". Let's catch that.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"try\\n{\\n  string text = File.ReadAllText(\\\"fileDoesNotExist.txt\\\");\\n  Console.WriteLine(text);\\n}\\ncatch (Exception e)\\n{\\n  Console.WriteLine(e.Message);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Could not find file '[. . .]/fileDoesNotExist.txt'.\\n\")), mdx(\"p\", null, \"Now we have a much more manageable error, but also our program did not crash. Let's try once more with a file that exists. I am using a \\\"text.txt\\\" file and printing its content.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"try\\n{\\n  string text = File.ReadAllText(\\\"text.txt\\\");\\n  Console.WriteLine(text);\\n}\\ncatch (Exception e)\\n{\\n  Console.WriteLine(e.Message);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"This is a line\\nThis is second line\\nThis is 3rd\\nThis includes a double, 3.25\\nThis has \\\"quotes\\\"\\n\")), mdx(\"p\", null, \"Now our file is read, the code inside the try-block is executed, and the catch-block is not executed, as the try-condition worked.\"), mdx(\"h2\", {\n    \"id\": \"shifting-the-responsibility\"\n  }, \"Shifting the responsibility\"), mdx(\"p\", null, \"Methods and constructors can throw exceptions. There are roughly two categories of exceptions. There are exceptions we have to handle, and exceptions we do not have to handle. We can handle exceptions by wrapping the code into a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"try-catch\"), \" block or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"throwing them out of the method\"), \".\"), mdx(\"p\", null, \"The code below reads the file given to it as a parameter line by line. Reading a file can throw an exception -- for example the file might not exist or the program does not have read rights to the file. This kind of exception has to be handled. We handle the exception by wrapping the code into a try-catch block. In this example we do not really care about the exception, but we do print a message to the user about it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  ReadLines(\\\"text.txt\\\").ForEach(Console.WriteLine);\\n}\\n\\n\\npublic static List<string> ReadLines(string fileName)\\n{\\n  List<string> list = new List<string>();\\n  try\\n  {\\n    string[] lines = File.ReadAllLines(fileName);\\n    list = new List<string>(lines);\\n  }\\n  catch (Exception e)\\n  {\\n    Console.WriteLine(e.Message);\\n  }\\n  return list;\\n}\\n\")), mdx(\"p\", null, \"A programmer can also leave the exception unhandled and shift the responsibility for handling it to whomever calls the method. We can shift the responsibility of handling an exception forward by throwing the exception out of a method. Notice on throwing an exception forward \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"throw new \", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"ExceptionType\")), \" is added in the method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  try\\n  {\\n    ReadLines(\\\"nonExistingFile.txt\\\").ForEach(Console.WriteLine);\\n  }\\n  catch (Exception e)\\n  {\\n    Console.WriteLine(\\\"Caught in Main!\\\");\\n  }\\n}\\n\\n\\npublic static List<string> ReadLines(string fileName)\\n{\\n  List<string> list = new List<string>();\\n  if (!File.Exists(fileName))\\n  {\\n    throw new System.IO.FileNotFoundException();\\n  }\\n  string[] lines = File.ReadAllLines(fileName);\\n  list = new List<string>(lines);\\n\\n  return list;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Caught in Main!\\n\")), mdx(\"h2\", {\n    \"id\": \"throwing-exceptions\"\n  }, \"Throwing exceptions\"), mdx(\"p\", null, \"In the previous topic, we already threw our first exception. Let's look into that a little deeper.\"), mdx(\"p\", null, \"The throw command throws an exception. For example a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FormatException\"), \" can be done with command throw new FormatException(). The following code always throws an exception.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  throw new FormatException();\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Unhandled exception. System.FormatException: One of the identified items was in an invalid format.\\n[. . .]\\n\")), mdx(\"p\", null, \"One exception which the user does not have to prepare for is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \". The ArgumentException tells the user that the values given to a method or a constructor as parameters are wrong. It can be used when we want to ensure certain parameter values.\"), mdx(\"p\", null, \"Lets create class Grade. It gets a integer representing a grade as a constructor parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Grade\\n  {\\n    public int grade { get; }\\n\\n    public Grade(int grade)\\n    {\\n      this.grade = grade;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"We want that the grade fills certain criteria. The grade has to be an integer between 0 and 5. If it is something else, we want to throw an exception. Let's add a conditional statement to the constructor, which checks if the grade fills the criteria. If it does not, we throw the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \" with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"throw new ArgumentException(\\\"Grade must be between 0 and 5.\\\");\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  public class Grade\\n  {\\n    public int grade { get; }\\n\\n    public Grade(int grade)\\n    {\\n      if (grade < 0 || grade > 5)\\n      {\\n        throw new ArgumentException(\\\"Grade must be between 0 and 5.\\\");\\n      }\\n      this.grade = grade;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's try this in action\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Grade grade = new Grade(3);\\nConsole.WriteLine(grade.grade);\\n\\nGrade illegalGrade = new Grade(22);\\n// exception happens, execution will not continue from here\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"3\\nUnhandled exception. System.ArgumentException: Grade must be between 0 and 5.\\n   [. . .]\\n\")), mdx(\"p\", null, \"Exceptions which must be handled are exceptions which are checked for during compilation. Due to this, some exceptions have to be prepared for with a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"try-catch\"), \" block or by throwing them out of a method with a throws attribute in a method declaration. For example exceptions related to handling files, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IOException\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FileNotFoundException\"), \", are this kind of exceptions.\"), mdx(\"p\", null, \"Some exceptions are not checked for during compilation. They can be thrown during execution. These kinds of exceptions do not have to be handled with a try-catch block. For example \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NullReferenceException\"), \" are this kind of exceptions.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Now we are able to throw our own custom exceptions, which can be caught just like any other exception.\"), mdx(\"h2\", {\n    \"id\": \"details-of-the-exception\"\n  }, \"Details of the exception\"), mdx(\"p\", null, \"A catch block defines which exception to prepare for with catch \", \"(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Exception e\"), \")\", \". The details of the exception are saved to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"e\"), \" variable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"try {\\n    // program code which might throw an exception\\n} catch (Exception e) {\\n    // details of the exception are stored in the variable e\\n}\\n\")), mdx(\"p\", null, \"We have already used the property \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Message\"), \". In it is stored the message that describes the exception. Another useful property is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"StackTrace\"), \", which gives us a string representation of the immediate frames on the call stack.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Unhandled exception. System.ArgumentException: Grade must be between 0 and 5.\\n   at Exercise001.Grade..ctor(Int32 grade) in [. . .]]/Grade.cs:line 14\\n   at Exercise001.Program.Main(String[] args) in []. . .]/Program.cs:line 14\\n\")), mdx(\"p\", null, \"We read a stack trace from the bottom up. At the bottom is the first call, so the execution of the program has begun from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Main()\"), \" method for the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Program\"), \" class. Line 14 of the Main method was used to create the new Grade object, with illegal parameters. Line 14 of the Grade class is the constructor, and it has now thrown and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \". The details of an exception are very useful when trying to pinpoint where an error happens.\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '003 ArgumentException',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Let's practise a little parameter validation with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \" exception. There is a class called Person in the exercise:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1\")), mdx(\"p\", null, \"The constructor of the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \" should ensure that the name given as the parameter is not null, empty, or over 40 characters in length. If these conditions are not met, the constructor should throw an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \".\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Nothingness, or null value comparison should be done first, otherwise we might get a NullReferenceException instead of our own exception.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2\")), mdx(\"p\", null, \"In the contsructor, the age should between 0 and 120. If these conditions are not met, the constructor should throw an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \".\")), mdx(Exercise, {\n    title: '004 Sensors and Temperature',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"We have the following interface at our disposal:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise004\\n{\\n  public interface ISensor\\n  {\\n    bool IsOn();    // returns true if the sensor is on\\n    void SetOn();      // sets the sensor on\\n    void SetOff();     // sets the sensor off\\n    int Read();        // returns the value of the sensor if it's on\\n                       // if the sensor is not on throw a IllegalStateException\\n  }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1\")), mdx(\"p\", null, \"Create a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"StandardSensor\"), \" that implements the interface ISensor.\"), mdx(\"p\", null, \"A standard sensor is always on. Calling the methods \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SetOn\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SetOff\"), \" has no effect. The StandardSensor must have a constructor that takes one integer parameter. The method call Read returns the number that was given to the constructor.\"), mdx(\"p\", null, \"An example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"StandardSensor ten = new StandardSensor(10);\\nStandardSensor minusFive = new StandardSensor(-5);\\n\\nConsole.WriteLine(ten.Read());\\nConsole.WriteLine(minusFive.Read());\\n\\nConsole.WriteLine(ten.IsOn());\\nten.SetOff();\\nConsole.WriteLine(ten.IsOn());\\n\")), mdx(\"p\", null, \"Sample output\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"10\\n-5\\ntrue\\ntrue\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2\")), mdx(\"p\", null, \"Create a class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TemperatureSensor\"), \" that implements the ISensor interface.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The constructor takes no parameters.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"At first a temperature sensor is off. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the method Read is called and the sensor is on, the sensor randomly chooses an integer in the range -30...30 and returns it. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the sensor is off, the method Read throws an \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"InvalidOperationException\"), \".\")), mdx(\"p\", null, \"An example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TemperatureSensor temperatureSensor = new TemperatureSensor();\\ntemperatureSensor.SetOn();\\nConsole.WriteLine(temperatureSensor.Read());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"23\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#exceptions","title":"Exceptions","items":[{"url":"#handling-exceptions","title":"Handling exceptions"},{"url":"#catching-file-exceptions","title":"Catching file exceptions"},{"url":"#shifting-the-responsibility","title":"Shifting the responsibility"},{"url":"#throwing-exceptions","title":"Throwing exceptions"},{"url":"#details-of-the-exception","title":"Details of the exception"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Exceptions"}}},"pageContext":{"id":"496da58a-1f77-5bc3-b9ce-9d0b76f0070c"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
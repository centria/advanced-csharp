{"componentChunkName":"component---src-templates-docs-js","path":"/part08/part08-1","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dictionaries\",\n  \"nav_order\": 81,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One of the most commonly used data structures among lists is  a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dictionary\"), \". In C#, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.8\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Dictionary<TKey,TValue> Class\")), \" is located in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Collections.Generic\"), \" Namespace. But what does it do?\"), mdx(\"p\", null, \"Data in dictionaries is stored as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"key-value pairs\"), \", where values can be added, retrieved, and deleted using keys. \"), mdx(\"p\", null, \"In the example below, a Dictionary object has been created to search for cities by their postal codes, after which four postal code-city pairs have been added to the Dictionary object. At the end of it, the postal code \\\"00710\\\" is retrieved from the dictionary. Both the postal code and the city are represented as strings.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Exercise001\\n{\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\n      postalCodes.Add(\\\"00710\\\", \\\"Helsinki\\\");\\n      postalCodes.Add(\\\"90014\\\", \\\"Oulu\\\");\\n      postalCodes.Add(\\\"33720\\\", \\\"Tampere\\\");\\n      postalCodes.Add(\\\"33014\\\", \\\"Tampere\\\");\\n\\n      Console.WriteLine(postalCodes[\\\"33720\\\"]);\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Tampere\\n\")), mdx(\"p\", null, \"The internal state of the dictionary created above looks like this. Each key refers to some value.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://raw.githubusercontent.com/centria/advanced-csharp/master/src/images//part8-1-dict.png\",\n    \"alt\": \"Dictionary\"\n  })), mdx(\"p\", null, \"If the dictionary does not contain the key used for search, we get a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"KeyNotFoundException\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\npostalCodes.Add(\\\"00710\\\", \\\"Helsinki\\\");\\npostalCodes.Add(\\\"90014\\\", \\\"Oulu\\\");\\npostalCodes.Add(\\\"33720\\\", \\\"Tampere\\\");\\npostalCodes.Add(\\\"33014\\\", \\\"Tampere\\\");\\n\\nConsole.WriteLine(postalCodes[\\\"67100\\\"]);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Unhandled exception. System.Collections.Generic.KeyNotFoundException: The given key '67100' was not present in the dictionary.\\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\\n   at Exercise001.Program.Main(String[] args) in /mnt/c/Users/HeikkiHei/Documents/coding-exercises/Exercise001/Program.cs:line 17\\n\")), mdx(\"p\", null, \"Two type parameters are required when creating a dictionary - the type of the key and the type of the value added. If the keys of the dictionary are of type string, and the values of type integer, the dictionary is created with the following statement \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, integer> dict = new Dictionary<string, integer>();\\n\")), mdx(\"p\", null, \"Adding to the dictionary is done through the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Add(\", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"key\"), \", \", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"value\"), \")\"), \" method that has two parameters, one for the key, the other for the value. Retrieving from a dictionary is done with the familiar \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dictionary\", \"[\", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"key\"), \"]\"), \" syntax. How ever, this time we are looking for a value with a key, and not with an index.\"), mdx(\"h2\", {\n    \"id\": \"dictionary-keys-correspond-to-a-single-value-at-most\"\n  }, \"Dictionary Keys Correspond to a Single Value at Most\"), mdx(\"p\", null, \"The dictionary has a maximum of one value per key. If a new key-value pair is added to the dictionary, but the key has already been associated with some other value stored in the dictionary, we will get an ArgumentException:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\npostalCodes.Add(\\\"67100\\\", \\\"Kokkola\\\");\\npostalCodes.Add(\\\"67100\\\", \\\"Karleby\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Unhandled exception. System.ArgumentException: An item with the same key has already been added. Key: 67100\\n   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)\\n   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)\\n\")), mdx(\"p\", null, \"For this, we can prepare ourselves, by checking if a value already exists in the dictionary, and only if it does not, we add the new value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\npostalCodes.Add(\\\"00710\\\", \\\"Helsinki\\\");\\npostalCodes.Add(\\\"90014\\\", \\\"Oulu\\\");\\npostalCodes.Add(\\\"33720\\\", \\\"Tampere\\\");\\npostalCodes.Add(\\\"33014\\\", \\\"Tampere\\\");\\npostalCodes.Add(\\\"67100\\\", \\\"Kokkola\\\");\\npostalCodes.Add(\\\"99999\\\", null);\\n\\nif (!postalCodes.ContainsKey(\\\"67100\\\"))\\n{\\n  postalCodes.Add(\\\"67100\\\", \\\"Karleby\\\");\\n}\\n\")), mdx(\"p\", null, \"This way our program does not crash, when we try to change the value for \\\"67100\\\". To see what our dictionary contains, we can use a foreach-loop for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"KeyValuePair\"), \" objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"foreach (KeyValuePair<string, string> kvp in postalCodes)\\n{\\n  Console.WriteLine(\\\"Key = {0}, Value = {1}\\\",\\n      kvp.Key, kvp.Value);\\n}\\n\")), mdx(\"p\", null, \"And it prints like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Key = 00710, Value = Helsinki\\nKey = 90014, Value = Oulu\\nKey = 33720, Value = Tampere\\nKey = 33014, Value = Tampere\\nKey = 67100, Value = Kokkola\\nKey = 99999, Value = \\n\")), mdx(\"p\", null, \"You might notice a different way of printing the strings. What we did there was \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\"\n  }, \"String interpolation\"), \".\"), mdx(\"p\", null, \"As you can see, we can also give a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \" as a value. We cannot, however, give null as a key, or we will get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentNullException\"), \".\"), mdx(\"h2\", {\n    \"id\": \"a-reference-type-variable-as-a-dictionary-value\"\n  }, \"A Reference Type Variable as a Dictionary Value\"), mdx(\"p\", null, \"Let's take a look at how a spreadsheet works using a library example. You can search for books by book title. If a book is found with the given search term, the library returns a reference to the book. Let's begin by creating an example class Book that has its name, content and the year of publication as instance variables.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Book\\n{\\n  public string name { get; set; }\\n  public string content { get; set; }\\n  public int published { get; set; }\\n\\n  public Book(string name, int published, string content)\\n  {\\n    this.name = name;\\n    this.published = published;\\n    this.content = content;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return \\\"Name: \\\" + this.name + \\\" (\\\" + this.published + \\\")\\\\n\\\"\\n        + \\\"Content: \\\" + this.content;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's create a dictionary that uses the book's name as a key, i.e., a string-type object, and the book we've just created as the value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, Book> directory = new Dictionary<string, Book>();\\n\")), mdx(\"p\", null, \"The dictionary above uses \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"string\"), \" as a key. Let's expand the example so that two books are added to the dictionary, \\\"Sense and Sensibility\\\" and \\\"Pride and Predujice\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPredujice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\n\\nDictionary<string, Book> directory = new Dictionary<string, Book>();\\ndirectory.Add(senseAndSensibility.name, senseAndSensibility);\\ndirectory.Add(prideAndPredujice.name, prideAndPredujice);\\n\")), mdx(\"p\", null, \"Books can be retrieved from the directory by book name. A search for \\\"Persuasion\\\" will not produce any results, in which case the dictionary gives an error. The book \\\"Pride and Prejudice\\\" is found, however. Let's play it safe, and put both inside an if:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"if (directory.ContainsKey(\\\"Persuation\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Persuasion\\\"]);\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Book not found!\\\");\\n}\\n\\nConsole.WriteLine();\\nif (directory.ContainsKey(\\\"Pride and Prejudice\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Pride and Prejudice\\\"]);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Book not found!\\n\\nName: Pride and Prejudice (1813)\\nContent: ....\\n\")), mdx(\"h2\", {\n    \"id\": \"when-should-dictionaries-be-used\"\n  }, \"When Should Dictionaries Be Used?\"), mdx(\"p\", null, \"The dictionary is implemented in such a way that searching by a key is very fast. The dictionary  generates a \\\"hash value\\\" from the key, i.e., a piece of code, which is used to store the value a specific location. When a key is used to retrieve information from a dictionary, this particular code identifies the location where the value associated with the key is. In practice, it's not necessary to go through all the key-value pairs in the dictionary when searching for a key; the set that's checked is significantly smaller. \"), mdx(\"p\", null, \"Consider the library example that was introduced above. The whole program could just as well have been implemented using a list. In that case, the books would be placed on the list instead of the directory, and the book search would happen by iterating over the list.\"), mdx(\"p\", null, \"In the example below, the books have been stored in a list and searching for them is done by going through the list.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<Book> books = new List<Book>();\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPrejudice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\nbooks.Add(senseAndSensibility);\\nbooks.Add(prideAndPrejudice);\\n\\n// searching for a book named Persuasion\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Persuation\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\n\\nConsole.WriteLine();\\n// searching for a book named Sense and Sensibility\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Sense and Sensibility\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"\\nName: Sense and Sensibility (1811)\\nContent: ...\\n\")), mdx(\"p\", null, \"Now the program works quite the same as our Dictionary version, right?\"), mdx(\"p\", null, \"Functionally, yes. Let's however, consider the performance of the program. C#'s DateTime() has property \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ticks\"), \", which represents the given date and time of a DateTime instance. A Tick is one hundred nanoseconds.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<Book> books = new List<Book>();\\n\\n// Add 10 million books to the list\\n\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPrejudice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\nbooks.Add(senseAndSensibility);\\nbooks.Add(prideAndPrejudice);\\n\\nDateTime start = DateTime.Now;\\n\\n// searching for a book named Persuasion\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Persuation\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\n\\nConsole.WriteLine();\\n\\n// searching for a book named Sense and Sensibility\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Sense and Sensibility\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\nDateTime end = DateTime.Now;\\nConsole.WriteLine(\\\"Time elapsed: \\\" + (end.Ticks - start.Ticks)/10000.0 + \\\" milliseconds\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Name: Sense and Sensibility (1811)\\nContent: ...\\nTime elapsed: 390.5467 millisecond\\n\")), mdx(\"p\", null, \"With 10 million (and 2) books, it takes almost half a second to find two books. Of course, the way in which the list is ordered has an effect. If the book being searched was first on the list, the program would be faster. On the other hand, if the book were not on the list, the program would have to go through all of the books in the list before determining that such book does not exist.\"), mdx(\"p\", null, \"Let's consider the same program using a dictionary.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"\\nDictionary<string, Book> directory = new Dictionary<string, Book>();\\n\\n// Add 10 million books to the dictionary\\n\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPredujice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\ndirectory.Add(senseAndSensibility.name, senseAndSensibility);\\ndirectory.Add(prideAndPredujice.name, prideAndPredujice);\\n\\nDateTime start = DateTime.Now;\\n\\nif (directory.ContainsKey(\\\"Persuation\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Persuasion\\\"]);\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Book not found!\\\");\\n}\\n\\nConsole.WriteLine();\\nif (directory.ContainsKey(\\\"Pride and Prejudice\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Pride and Prejudice\\\"]);\\n}\\n\\nDateTime end = DateTime.Now;\\nConsole.WriteLine(\\\"Time elapsed: \\\" + (end.Ticks - start.Ticks)/10000.0 + \\\" milliseconds\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Book not found!\\n\\nName: Pride and Prejudice (1813)\\nContent: ....\\nTime elapsed: 5.8134 milliseconds\\n\")), mdx(\"p\", null, \"As we can see, the dictionary is quite much faster, and that's with searching only for 2 books. What if we needed to search for 3? Or 100?\"), mdx(\"h2\", {\n    \"id\": \"dictionary-as-an-instance-variable\"\n  }, \"Dictionary as an Instance Variable\"), mdx(\"p\", null, \"The example considered above on storing books is problematic in that the book's spelling format must be remembered accurately. Someone may search for a book with a lowercase letter, another may, for example, enter a space to begin typing a name. Let's take a look at a slightly more forgiving search by book title.\"), mdx(\"p\", null, \"We make use of the tools provided by the string-class to handle strings. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToLower()\"), \" method creates a new string with all letters converted to lowercase. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Trim()\"), \" method, on the other hand, creates a new string where empty characters such as spaces at the beginning and end have been removed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string text = \\\"Pride and Prejudice     \\\";\\ntext = text.ToLower(); // text currently \\\"pride and prejudice     \\\"\\ntext = text.Trim(); // text now \\\"pride and prejudice\\\"\\n\")), mdx(\"p\", null, \"The conversion of the string described above will result in the book being found, even if the user happens to type the title of the book with lower-case letters.\"), mdx(\"p\", null, \"Let's create a Library class that encapsulates a dictionary containing books, and enables you to case-independent search for books. We'll add methods for adding, retrieving and deleting to the Library class. Each of these is based on a sanitized name - this involves converting the name to lowercase and removing extrenous spaces from the beginning and end.\"), mdx(\"p\", null, \"Let's first outline the method for adding. The book is added to the dictionary with the book name as the key and the book itself as the value. Since we want to allow for minor misspellings, such as capitalized or lower-cased strings, or ones with spaces at the beginning and/or end, the key - the title of the book - is converted to lowercase, and spaces at the beginning and end are removed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Library\\n{\\n  private Dictionary<string, Book> directory;\\n\\n  public Library()\\n  {\\n    this.directory = new Dictionary<string, Book>();\\n  }\\n\\n  public void AddBook(Book book)\\n  {\\n    string name = book.name;\\n    if (name == null)\\n    {\\n      name = \\\"\\\";\\n    }\\n\\n    name = name.ToLower();\\n    name = name.Trim();\\n\\n    if (this.directory.ContainsKey(name))\\n    {\\n      Console.WriteLine(\\\"Book is already in the library!\\\");\\n    }\\n    else\\n    {\\n      directory.Add(name, book);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ContainsKey\"), \" method of the directory is being used above to check for the existence of a key. The method returns true if any value has been added to the directory with the given key. Otherwise, the method returns false.\"), mdx(\"p\", null, \"We can already see that code dealing with string sanitizion is needed in every method that handles a book, which makes it a good candiate for a separate helper method. The method is implemented as a class method since it doesn't handle object variables.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static string SanitizedString(string input)\\n{\\n  if (input == null)\\n  {\\n    return \\\"\\\";\\n  }\\n\\n  input = input.ToLower();\\n  return input.Trim();\\n}\\n\")), mdx(\"p\", null, \"The implementation is much neater when the helper method is used.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Exercise001\\n{\\n  public class Library\\n  {\\n    private Dictionary<string, Book> directory;\\n\\n    public Library()\\n    {\\n      this.directory = new Dictionary<string, Book>();\\n    }\\n\\n    public void AddBook(Book book)\\n    {\\n      string name = SanitizedString(book.name);\\n\\n      if (this.directory.ContainsKey(name))\\n      {\\n        Console.WriteLine(\\\"Book is already in the library!\\\");\\n      }\\n      else\\n      {\\n        directory.Add(name, book);\\n      }\\n    }\\n\\n    public Book GetBook(string bookTitle)\\n    {\\n      bookTitle = SanitizedString(bookTitle);\\n      if (this.directory.ContainsKey(bookTitle))\\n      {\\n        return this.directory[bookTitle];\\n      }\\n      else\\n      {\\n        return null;\\n      }\\n    }\\n\\n    public void RemoveBook(string bookTitle)\\n    {\\n      bookTitle = SanitizedString(bookTitle);\\n\\n      if (this.directory.ContainsKey(bookTitle))\\n      {\\n        this.directory.Remove(bookTitle);\\n      }\\n      else\\n      {\\n        Console.WriteLine(\\\"Book was not found, cannot be removed!\\\");\\n      }\\n    }\\n\\n\\n    public static string SanitizedString(string input)\\n    {\\n      if (input == null)\\n      {\\n        return \\\"\\\";\\n      }\\n\\n      input = input.ToLower();\\n      return input.Trim();\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's see this in action\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPredujice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\n\\nLibrary library = new Library();\\nlibrary.AddBook(senseAndSensibility);\\nlibrary.AddBook(prideAndPredujice);\\n\\nConsole.WriteLine(library.GetBook(\\\"pride and prejudice\\\"));\\nConsole.WriteLine();\\n\\nConsole.WriteLine(library.GetBook(\\\"PRIDE AND PREJUDICE\\\"));\\nConsole.WriteLine();\\n\\nConsole.WriteLine(library.GetBook(\\\"SENSE\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Name: Pride and Prejudice (1813)\\nContent: ....\\n\\nName: Pride and Prejudice (1813)\\nContent: ....\\n\")), mdx(\"p\", null, \"In the above example, we adhered to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DRY (Don't Repeat Yourself)\"), \" principle according to which code duplication should be avoided. Sanitizing a string, i.e., changing it to lowercase, and trimming, i.e., removing empty characters from the beginning and end, would have been repeated many times in our library class without the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SanitizedString\"), \" method. Repetitive code is often not noticed until it has already been written, which means that it almost always makes it's way into the code. There's nothing wrong with that - the important thing is that the code is cleaned up so that places that require tidying up are noticed.\"), mdx(\"h2\", {\n    \"id\": \"going-through-a-dictionarys-keys\"\n  }, \"Going Through A Dictionary's Keys\"), mdx(\"p\", null, \"We may sometimes want to search for a book by a part of it's title. The get method (dictionary\", \"[\", \"key\", \"]\", \") in the dictionary is not applicable in this case as it's used to search by a specific key. Searching by a part of a book title is not possible with it.\"), mdx(\"p\", null, \"We can go through the values \\u200B\\u200Bof a dictionary by using a for-each loop on the KeyCollection returned by the Keys property of the dictionary.\"), mdx(\"p\", null, \"Below, a search is performed for all the books whose names contain the given string.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public List<Book> GetBooksByPart(string titlePart)\\n{\\n  List<Book> books = new List<Book>();\\n  titlePart = SanitizedString(titlePart);\\n  Dictionary<string, Book>.KeyCollection keys = this.directory.Keys;\\n\\n  foreach (string bookTitle in keys)\\n  {\\n    if (bookTitle.Contains(titlePart))\\n    {\\n      books.Add(this.directory[bookTitle]);\\n    }\\n  }\\n  return books;\\n}\\n\")), mdx(\"p\", null, \"This way, however, we lose the speed advantage that comes with the dictionary. The dictionary is implemented in such a way that searching by a single key is extremely fast. The example above goes through all the book titles when looking for the existence of a single book using a particular key.\"), mdx(\"h2\", {\n    \"id\": \"going-through-a-dictionarys-values\"\n  }, \"Going Through A Dictionary's Values\"), mdx(\"p\", null, \"The preceding functionality could also be implemented by going through the dictionary's values. The set of values can be retrieved with the dictionary's Values\\u200B\\u200B() property. This set of values can also be iterated ober \\u200B\\u200Bwith a for-each loop.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public List<Book> GetBooksByPart(string titlePart)\\n{\\n  List<Book> books = new List<Book>();\\n  titlePart = SanitizedString(titlePart);\\n  Dictionary<string, Book>.ValueCollection values = this.directory.Values;\\n\\n  foreach (Book book in values)\\n  {\\n    if (book.name.Contains(titlePart))\\n    {\\n      books.Add(book);\\n    }\\n  }\\n  return books;\\n}\\n\")), mdx(\"p\", null, \"As with the previous example, the speed advantage that comes with the dictionary is lost.\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '001 Nicknames',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"In the Main-method create a new Dictionary< string , string > object. Store the names and nicknames of the following example in this dictionary so, that the name is the key and the nickname is the value.\"), mdx(\"p\", null, \"Then get the names from the dictionary, and print the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"matthew's nickname is matt\\nmichael's nickname is mix\\narthur's nickname is artie\\n\")), mdx(\"p\", null, \"Use a foreach-loop to print over KeyValuePair for the printing.\")), mdx(Exercise, {\n    title: '002 Abbreviations',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Create the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Abbreviations\"), \" for managing common abbreviations. The class must have a constructor, which does not take any parameters. The class must also provide the following methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public void AddAbbreviation(string abbreviation, string explanation)\"), \" adds a new abbreviation and its explanation. You can use the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \".Add\"), \" method for the dictionary and assume we never add the same abbrevation twice.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public bool HasAbbreviation(string abbreviation)\"), \" checks if an abbreviation has already been added; returns true if it has and false if it has not.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public string FindExplanationFor(string abbreviation)\"), \" finds the explanation for an abbreviation; returns \\\"not found\\\" if the abbreviation has not been added yet.\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Use HasAbbreviation in your FindExplanationFor to avoid errors!\"), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Abbreviations abbreviations = new Abbreviations();\\nabbreviations.AddAbbreviation(\\\"e.g\\\", \\\"for example\\\");\\nabbreviations.AddAbbreviation(\\\"etc.\\\", \\\"and so on\\\");\\nabbreviations.AddAbbreviation(\\\"i.e\\\", \\\"more precisely\\\");\\n\\nstring text = \\\"e.g i.e etc. lol\\\";\\n\\nforeach (string part in text.Split(\\\" \\\"))\\n{\\n  Console.WriteLine(abbreviations.FindExplanationFor(part));\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"for example\\nand so on\\nmore precisely\\nnot found\\n\"))), mdx(Exercise, {\n    title: '003 Print Dictionary Keys',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Exercise template contains a class Program. Implement the following class methods in the class:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintKeys(Dictionary<string,string> dict)\"), \", prints all the keys in the dictionary given as a parameter.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintKeysWhere(Dictionary<string,string> dict, string text)\"), \" prints the keys in the dictionary given as a parameter, which contain the string given as a parameter.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintValuesOfKeysWhere(Dictionary<string,string> dict, string text)\"), \", prints the values in the given dictionary whichs keys contain the given string.\")), mdx(\"p\", null, \"Example of using the class methods:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string,string> dict = new Dictionary<string, string>();\\ndict.Add(\\\"f.e\\\", \\\"for example\\\");\\ndict.Add(\\\"etc.\\\", \\\"and so on\\\");\\ndict.Add(\\\"i.e\\\", \\\"more precisely\\\");\\n\\nPrintKeys(dict);\\nConsole.WriteLine(\\\"---\\\");\\nPrintKeysWhere(dict, \\\"i\\\");\\nConsole.WriteLine(\\\"---\\\");\\nPrintValuesOfKeysWhere(dict, \\\".e\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"f.e \\netc. \\ni.e \\n--- \\ni.e \\n--- \\nfor example \\nmore precisely\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \" The order of the output can vary, as the dictionary does not guarantee the order of the objects in it.\")), mdx(Exercise, {\n    title: '004 Book Dictionary',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"The exercise template contains the already familiar classes Book and Program. In the class Program implement the following class methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintValues(Dictionary< string, Book \", \">\", \" dictionary)\"), \", which prints all the values in the dictionary given as a parameter using the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ToString\"), \" method of the Book objects.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintValueIfNameContains(Dictionary< string, Book \", \">\", \" dictionary, string text)\"), \", which prints only the Books in the given dictionary whose name contains the given string. You can find out the name of a Book with the property \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"name\"), \".\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, Book> books = new Dictionary<string, Book>();\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPrejudice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\nbooks.Add(senseAndSensibility.name, senseAndSensibility);\\nbooks.Add(prideAndPrejudice.name, prideAndPrejudice);\\n\\nPrintValues(books);\\nConsole.WriteLine(\\\"-- -- -- --\\\");\\nPrintValueIfNameContains(books, \\\"prejud\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Name: Sense and Sensibility (1811)\\nContent: ...\\nName: Pride and Prejudice (1813)\\nContent: ....\\n-- -- -- --\\nName: Pride and Prejudice (1813)\\nContent: ....\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The order of the output can vary, as the dictionary does not guarantee the order of the objects in it.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The search is case-insensitive!\")), mdx(Exercise, {\n    title: '005 I Owe You',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Create a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IOU\"), \" which has the following methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"constructor \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public IOU()\"), \" creates a new IOU\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public void ChangeDebt(string toWhom, int amount)\"), \" saves the amount owed and the person owed to to the IOU. You can use this to also lower the debt, but the total amount cannot be negative!\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public int HowMuchDoIOweTo(string toWhom)\"), \" returns the amount owed to the person whose name is given as a parameter. If the person cannot be found, it returns 0.\")), mdx(\"p\", null, \"The class can be used like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"IOU mattsIOU = new IOU();\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", 51);\\nmattsIOU.ChangeDebt(\\\"Michael\\\", 30);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Michael\\\"));\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Heikki\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"51\\n30\\n0\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \" If a new debt is added, the debt increases or decreases. Take that into account in your code. Also, the the total amount should not be negative! \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"IOU mattsIOU = new IOU();\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", -10);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", 51);\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", 30);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", -30);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", -80);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"0\\n81\\n51\\n0\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#dictionary-keys-correspond-to-a-single-value-at-most","title":"Dictionary Keys Correspond to a Single Value at Most"},{"url":"#a-reference-type-variable-as-a-dictionary-value","title":"A Reference Type Variable as a Dictionary Value"},{"url":"#when-should-dictionaries-be-used","title":"When Should Dictionaries Be Used?"},{"url":"#dictionary-as-an-instance-variable","title":"Dictionary as an Instance Variable"},{"url":"#going-through-a-dictionarys-keys","title":"Going Through A Dictionary's Keys"},{"url":"#going-through-a-dictionarys-values","title":"Going Through A Dictionary's Values"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Dictionaries"}}},"pageContext":{"id":"ad28424c-fd7d-560d-858b-22a69ae6762d"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
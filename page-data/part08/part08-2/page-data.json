{"componentChunkName":"component---src-templates-docs-js","path":"/part08/part08-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Similarity of Objects\",\n  \"nav_order\": 82,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let's revise the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" method used to compare object, and become familiar with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \" method used in making approximate comparisons.\"), mdx(\"h2\", {\n    \"id\": \"method-to-test-for-equality---equals\"\n  }, \"Method to Test For Equality - \\\"Equals\\\"\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.object.Equals?view=netframework-4.8\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Equals method\")), \" checks by default whether the object given as a parameter has the same reference as the object its being compared to. In other words, the default behaviour checks whether the two objects are the same. If the reference is the same, the method returns true, and false otherwise.\"), mdx(\"p\", null, \"This can be illustrated with the following example. The Book class does not have its own implementation of the Equals method, so it falls back on the default implementation provided by C#.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book bookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\nBook anotherBookObject = bookObject;\\n\\nif (bookObject.Equals(anotherBookObject))\\n{\\n  Console.WriteLine(\\\"The books were the same\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The books weren't the same\\\");\\n}\\n\\n// we now create an object with the same content that's nonetheless its own object\\nanotherBookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\n\\nif (bookObject.Equals(anotherBookObject))\\n{\\n  Console.WriteLine(\\\"The books were the same\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The books weren't the same\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"The books were the same\\nThe books weren't the same\\n\")), mdx(\"p\", null, \"The internal structure of the book objects (i.e., the values of their instance variables ) in the previous example is the same, but only the first comparison prints \\\"The books were the same\\\". This is because the references are the same in the first case, i.e., the object is compared to itself. The second comparison is about two different entities, even though the variables have the same values.\"), mdx(\"p\", null, \"If we want to compare our own classes using the Equals method, then it must be defined inside the class. The method created accepts an Object-type reference as a parameter, which can be any object. The comparison first looks at the references. This is followed by checking the parameter object's type with the instanceof operation - if the object type does not match the type of our class, the object cannot be the same. We then create a version of the object that is of the same type as our class, after which the object variables are compared against each other.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override bool Equals(object compared)\\n{\\n  // if the variables are located in the same position, they are equal\\n  if (this == compared)\\n  {\\n    return true;\\n  }\\n\\n  // if the compared object is null or not of type Book, the objects are not equal\\n  if ((compared == null) || !this.GetType().Equals(compared.GetType()))\\n  {\\n    return false;\\n  }\\n  else\\n  {\\n    // convert the object to a Book object\\n    Book comparedBook = (Book)compared;\\n\\n    // if the values of the object variables are equal, the objects are, too\\n    return this.name == comparedBook.name && this.published == comparedBook.published && this.content == comparedBook.content;\\n  }\\n}\\n\")), mdx(\"p\", null, \"The Book-class in it's entirety.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Book\\n  {\\n    public string name { get; set; }\\n    public string content { get; set; }\\n    public int published { get; set; }\\n\\n    public Book(string name, int published, string content)\\n    {\\n      this.name = name;\\n      this.published = published;\\n      this.content = content;\\n    }\\n\\n    public override string Tostring()\\n    {\\n      return \\\"Name: \\\" + this.name + \\\" (\\\" + this.published + \\\")\\\\n\\\"\\n          + \\\"Content: \\\" + this.content;\\n    }\\n\\n    public override bool Equals(object compared)\\n    {\\n      // if the variables are located in the same position, they are equal\\n      if (this == compared)\\n      {\\n        return true;\\n      }\\n\\n      // if the compared object is null or not of type Book, the objects are not equal\\n      if ((compared == null) || !this.GetType().Equals(compared.GetType()))\\n      {\\n        return false;\\n      }\\n      else\\n      {\\n        // convert the object to a Book object\\n        Book comparedBook = (Book)compared;\\n\\n        // if the values of the object variables are equal, the objects are, too\\n        return this.name == comparedBook.name && this.published == comparedBook.published && this.content == comparedBook.content;\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now the book comparison returns \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \" if the instance variables of the books are the same.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book bookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\nBook anotherBookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\n\\nif (bookObject.Equals(anotherBookObject))\\n{\\n  Console.WriteLine(\\\"The books were the same\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The books weren't the same\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Book.cs(3,16): warning CS0659: 'Book' overrides Object.Equals(object o) but does not override Object.GetHashCode() [/mnt/c/Users/HeikkiHei/Documents/coding-exercises/Exercise001/Exercise001.csproj]\\n\\nThe books were the same\\n\")), mdx(\"p\", null, \"We also get the very familiar warning. Finally in this section, we will do something about it.\"), mdx(\"p\", null, \"The List also uses the Equals method in its internal implementation. If we don't define the Equals method in our objects, the contains method of the List does not work properly. If you try out the code below with two Book classes, one with the Equals method defined, and another without it, you'll see the difference.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<Book> books = new List<Book>();\\nBook bookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\nbooks.Add(bookObject);\\n\\nif (books.Contains(bookObject))\\n{\\n  Console.WriteLine(\\\"Book Object was found.\\\");\\n}\\n\\nbookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\n\\nif (!books.Contains(bookObject))\\n{\\n  Console.WriteLine(\\\"Book Object was not found.\\\");\\n}\\n\")), mdx(\"p\", null, \"This reliance on default methods such as Equals is actually the reason why C# demands that variables added to List and Dictionary are of reference type. Each reference type variable comes with default methods, such as Equals, which means that you don't need to change the internal implementation of the List class when adding variables of different types. \"), mdx(\"h2\", {\n    \"id\": \"approximate-comparison-with-dictionary\"\n  }, \"Approximate Comparison With Dictionary\"), mdx(\"p\", null, \"In addition to Equals, the GetHashCode method can also be used for approximate comparison of objects. The method creates from the object a \\\"hash code\\\", i.e, a number, that tells a bit about the object's content. If two objects have the same hash value, they may be equal. On the other hand, if two objects have different hash values, they are certainly unequal.\"), mdx(\"p\", null, \"Hash codes are used in Dictionaries, for instance. Dictionary's internal behavior is based on the fact that key-value pairs are stored in an array of lists based on the key's hash value. Each array index points to a list. The hash value identifies the array index, whereby the list located at the array index is traversed. The value associated with the key will be returned if, and only if, the exact same value is found in the list (equality comparison is done using the Equals method). This way, the search only needs to consider a fraction of the keys stored in the hash map.\"), mdx(\"p\", null, \"So far, we've only used string objects as Dictionary keys, which have conveniently had ready-made GetHashCode methods implemented. Let's create an example where this is not the case: we'll continue with the books and keep track of the books that are on loan. We'll implement the book keeping with a Dictionary. The key is the book and the value attached to the book is a string that tells the borrower's name:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<Book, string> borrowers = new Dictionary<Book, string>();\\n\\nBook bookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\nborrowers.Add(bookObject, \\\"Pekka\\\");\\nborrowers.Add(new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\"), \\\"Arto\\\");\\n\\nConsole.WriteLine(borrowers[bookObject]);\\nConsole.WriteLine(borrowers[new Book(\\\"Book Object\\\", 2000, \\\"...\\\")]);\\nConsole.WriteLine(borrowers[new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\")]);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Pekka\\nUnhandled exception. System.Collections.Generic.KeyNotFoundException: The given key 'Name: Book Object (2000) \\n[. . .]\\n\")), mdx(\"p\", null, \"We get an error, as the object created in the second Console.WriteLine does not match any key (neither does the third one, but the program quits on the first error).\"), mdx(\"p\", null, \"We find the borrower when searching for the same object that was given as a key to the dictionarys's Add method. However, when searching by the exact same book but with a different object,a borrower isn't found, and we get the error instead. The reason lies in the default implementation of the GetHashCode method in the Object class. The default implementation creates a HashCode value based on the object's reference, which means that books having the same content that are nonetheless different objects get different results from the GetHashCode method. As such, the object is not being searched for in the right place.\"), mdx(\"p\", null, \"For the Dictionary to work in the way we want it to, that is, to return the borrower when given an object with the correct content (not necessarily the same object as the original key), the class that's the key must overwrite the GetHashCode method in addition to the Equals method. The method must be overwritten so that it gives the same numerical result for all objects with the same content. Also, some objects with different contents may get the same result from the GetHashCode method. However, with the Dictionary's performance in mind, it is essential that objects with different contents get the same hash value as rarely as possible.\"), mdx(\"p\", null, \"We've previously used string objects as Dictionary keys, so we can deduce that the string class has a well-functioning GetHashCode implementation of its own. We'll Delegate, i.e., transfer the computational responsibility to the string object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override int GetHashCode()\\n{\\n  return this.name.GetHashCode();\\n}\\n\")), mdx(\"p\", null, \"The above solution is quite good. However, if name is null, we see a NullReferenceException error. Let'fix this by defining a condition: if the value of the name variable is null, we'll return the year of publication as the hash value.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override int GetHashCode()\\n{\\n  if (this.name == null)\\n  {\\n    return this.published;\\n  }\\n  return this.name.GetHashCode();\\n}\\n\")), mdx(\"p\", null, \"Now, all of the books that share a name are bundleded into one group. Let's improve it further so that the year of publiciation is also taken into account in the hash value calculation that's based on the book title.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override int GetHashCode()\\n{\\n  if (this.name == null)\\n  {\\n    return this.published;\\n  }\\n  return this.published + this.name.GetHashCode();\\n}\\n\")), mdx(\"p\", null, \"It's now possible to use the book as the hash map's key. This way the problem we faced earlier gets solved and the book borrowers are found:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<Book, string> borrowers = new Dictionary<Book, string>();\\n\\nBook bookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\nborrowers.Add(bookObject, \\\"Pekka\\\");\\nborrowers.Add(new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\"), \\\"Arto\\\");\\n\\nConsole.WriteLine(borrowers[bookObject]);\\nConsole.WriteLine(borrowers[new Book(\\\"Book Object\\\", 2000, \\\"...\\\")]);\\nConsole.WriteLine(borrowers[new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\")]);\\n\")), mdx(\"p\", null, \"Prints\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Pekka\\nPekka\\nArto\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Let's revise the ideas once more:\"), \" for a class to be used as a Dictionary's key, we need to define for it:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"method Equals , so that all equal or apporiximately equal objects cause the comparison to return true and all false for all the rest\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"method GetHashCode , so that as few objects as possible end up with the same hash value\")), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '006 Same Date',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"The exercise template contains a class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SimpleDate\"), \", which defines a date object based on a given day, month, and year. In this exercise you will expand the SimpleDate class with an equals method, which can tell if the dates are exactly the same.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"create a method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public override bool Equals(object compared)\"), \" for the SimpleDate class, which returns true if the date of the object passed to the method as a parameter is the same as the date of the object used to call the method.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"create a method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public override int GetHashCode()\"), \" for the SimpleDate class, which calculates a hash for the the SimpleDate object. Implement the calculation of the hash in way that there are as few similar hashes as possible between the years 1900 and 2100.\"))), mdx(\"p\", null, \"The Equals should work as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"SimpleDate d = new SimpleDate(1, 2, 2000);\\nConsole.WriteLine(d.Equals(\\\"heh\\\"));\\nConsole.WriteLine(d.Equals(new SimpleDate(5, 2, 2012)));\\nConsole.WriteLine(d.Equals(new SimpleDate(1, 2, 2000)));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"false\\nfalse\\ntrue\\n\"))), mdx(Exercise, {\n    title: '007 Vehicle Registry',\n    mdxType: \"Exercise\"\n  }, mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1\")), mdx(\"p\", null, \"European license plates have to parts, a two letter country code and a nationally unique license number. The license number is made up of numbers and characters. License plates are represented by the following class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class LicensePlate\\n{\\n  private string liNumber;\\n  private string country;\\n\\n  public LicensePlate(string country, string liNumber)\\n  {\\n    this.liNumber = liNumber;\\n    this.country = country;\\n  }\\n\\n\\n  public override string ToString()\\n  {\\n    return country + \\\" \\\" + liNumber;\\n  }\\n}\\n\")), mdx(\"p\", null, \"We want to be able to save the license plates in e.g Lists and to use them as keys in a Dictionary. Which, as explained above, means that the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \" methods need to be overwritten, or they won't work as intended. Implement the methods Equals and GetHashCode for the LicensePlate class.\"), mdx(\"p\", null, \"Example program:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"LicensePlate li1 = new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\");\\nLicensePlate li2 = new LicensePlate(\\\"FI\\\", \\\"UXE-465\\\");\\nLicensePlate li3 = new LicensePlate(\\\"D\\\", \\\"B WQ-431\\\");\\n\\nList<LicensePlate> finnishPlates = new List<LicensePlate>();\\nfinnishPlates.Add(li1);\\nfinnishPlates.Add(li2);\\n\\nLicensePlate newLi = new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\");\\nif (!finnishPlates.Contains(newLi))\\n{\\n  finnishPlates.Add(newLi);\\n}\\nConsole.WriteLine(\\\"Finnish: \\\");\\nforeach (LicensePlate plate in finnishPlates)\\n{\\n  Console.WriteLine(plate);\\n}\\n\\nDictionary<LicensePlate, string> owners = new Dictionary<LicensePlate, string>();\\nowners.Add(li1, \\\"Arto\\\");\\nowners.Add(li3, \\\"J\\xFCrgen\\\");\\n\\nConsole.WriteLine(\\\"Owners:\\\");\\nConsole.WriteLine(owners[new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\")]);\\nConsole.WriteLine(owners[new LicensePlate(\\\"D\\\", \\\"B WQ-431\\\")]);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Finnish: \\nFI ABC-123\\nFI UXE-465\\nOwners:\\nArto\\nJ\\xFCrgen\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2\")), mdx(\"p\", null, \"Implement the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"VehicleRegistry\"), \", which has the following methods:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public bool Add(LicensePlate licensePlate, string owner)\"), \" assigns the owner it received as a parameter to car corresponding with the license plate received as a parameter. If the license plate didn't have an owner returns \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \". If the license already had an owner attached, the method returns \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false and does nothing\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public string Get(LicensePlate licensePlate)\"), \" returns the owner of the car corresponding to the license plate received as a parameter. If the car isn't in the registry, returns an error message (of your choice).\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public bool Remove(LicensePlate licensePlate)\"), \" removes the license plate and attached data from the registry. Returns \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \" if removed successfully and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \" if the license plate wasn't in the registry.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public void PrintLicensePlates()\"), \" prints the license plates in the registry.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public void PrintOwners()\"), \" prints the owners of the cars in the registry. Each name should only be printed once, even if a particular person owns more than one car.\"))), mdx(\"p\", null, \"Now the program should work something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"LicensePlate li1 = new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\");\\nLicensePlate li2 = new LicensePlate(\\\"FI\\\", \\\"UXE-465\\\");\\nLicensePlate li3 = new LicensePlate(\\\"D\\\", \\\"B WQ-431\\\");\\nLicensePlate li4 = new LicensePlate(\\\"D\\\", \\\"B WQ-432\\\");\\nLicensePlate li5 = new LicensePlate(\\\"D\\\", \\\"B WQ-433\\\");\\n\\nVehicleRegistry register = new VehicleRegistry();\\n\\nregister.Add(li1, \\\"Arto\\\");\\nregister.Add(li2, \\\"Arto\\\");\\nregister.Add(li3, \\\"J\\xFCrgen\\\");\\nregister.Add(li4, \\\"J\\xFCrgen\\\");\\nregister.Add(li5, \\\"J\\xFCrgen\\\");\\n\\nConsole.WriteLine(\\\"Plates:\\\");\\nregister.PrintLicensePlates();\\n\\nConsole.WriteLine(\\\"Owners:\\\");\\nregister.PrintOwners();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Plates:\\nFI ABC-123\\nFI UXE-465\\nD B WQ-431\\nD B WQ-432\\nD B WQ-433\\nOwners:\\nArto\\nJ\\xFCrgen\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"In the printOwners method, you can create a list used for remembering the owners that were already printed. If an owner is not on the their name is printed and they are added to the list -- if an owner is on the list their name isn't printed.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#method-to-test-for-equality---equals","title":"Method to Test For Equality - \"Equals\""},{"url":"#approximate-comparison-with-dictionary","title":"Approximate Comparison With Dictionary"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Similarity of Objects"}}},"pageContext":{"id":"e0a3ed2a-de56-518f-8f36-266ce1fd2a73"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
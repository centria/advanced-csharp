{"componentChunkName":"component---src-templates-docs-js","path":"/part07/part07-1","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Projects\",\n  \"nav_order\": 71,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"projects\"\n  }, \"Projects\"), mdx(\"p\", null, \"So far we have let ourselves off easy: we have not done any projects ourselves, but we've been given templates in the exercises.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \".\\n\\u251C\\u2500\\u2500 src\\n\\u2502   \\u2514\\u2500\\u2500 Exercise001\\n\\u2502       \\u251C\\u2500\\u2500 Exercise.csproj\\n\\u2502       \\u251C\\u2500\\u2500 Program.cs\\n\\u2514\\u2500\\u2500 test\\n    \\u2514\\u2500\\u2500 Exercise001Test\\n        \\u251C\\u2500\\u2500 Exercise001Tests.csproj\\n        \\u2514\\u2500\\u2500 ProgramTest.cs\\n\")), mdx(\"p\", null, \" This is not a very reasonable way to create or maintain projects. We need to also learn how to create projects ourselves. \"), mdx(\"h2\", {\n    \"id\": \"creating-our-first-program\"\n  }, \"Creating our first program\"), mdx(\"p\", null, \"We have tried our hands with the very basic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet\"), \" command, mainly the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet run\"), \" to try how our exercises work locally. The command in question is part of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet\"), \" program we installed as a prerequisite for the basic course. The program has, of course, other commands available. We are going to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet new\"), \" to create our own program at this point.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The instructions are written with Visual Studio Code in mind, as we use that for our exercises.\"), mdx(\"p\", null, \"The following is an adaptation from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/core/tutorials/with-visual-studio-code?pivots=dotnet-5-0\"\n  }, \"here\"), \".\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Start Visual Studio Code\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Select \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"File > Open Folder\"), \" from the main menu\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Open Folder\"), \" dialog, create a HelloWorld folder and select it\")), mdx(\"p\", null, \"The folder name becomes the project name and the namespace name by default. You'll add code later in the tutorial that assumes the project namespace is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HelloWorld\"), \".\"), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Open the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Terminal\"), \"  in Visual Studio Code, and make sure you are in the correct folder (the one just created).\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In the terminal, enter the following command:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet new console\\n\")), mdx(\"p\", null, \"When using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dotnet 6.0\"), \" the template is quite simple, only containing the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Console.WriteLine(String)\"), \" method to display \\\"Hello World!\\\" in the console window.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// See https://aka.ms/new-console-template for more information\\nConsole.WriteLine(\\\"Hello, World!\\\");\\n\")), mdx(\"p\", null, \"In practice (and in older versions of dotnet), the template is something like the following:\"), mdx(\"p\", null, \"The template creates a simple \\\"Hello World\\\" application. It calls the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Console.WriteLine(String)\"), \" method to display \\\"Hello World!\\\" in the console window.\"), mdx(\"p\", null, \"The template code defines a class, Program, with a single method, Main, that takes a String array as an argument:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace HelloWorld\\n{\\n    using System;\\n\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            Console.WriteLine(\\\"Hello World!\\\");\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Main is the application entry point, the method that's called automatically by the runtime when it launches the application. Any command-line arguments supplied when the application is launched are available in the args array.\"), mdx(\"p\", null, \"To run the application, use the familiar \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet run\"), \" command.\"), mdx(\"h2\", {\n    \"id\": \"organizing-and-testing-using-the-newtypes-pets-sample\"\n  }, \"Organizing and testing using the NewTypes Pets Sample\"), mdx(\"p\", null, \"The following is adapted \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/core/tutorials/testing-with-cli\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"from this .NET Documentation\")), \".\"), mdx(\"h3\", {\n    \"id\": \"building-the-sample\"\n  }, \"Building the sample\"), mdx(\"p\", null, \"For the following steps, create your own files and folders if you wish to test creating the example.\"), mdx(\"p\", null, \"The animal types are logically organized into a folder structure that permits the addition of more types later, and tests are also logically placed in folders permitting the addition of more tests later.\"), mdx(\"p\", null, \"The sample contains two types, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Dog\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cat\"), \". For the NewTypes project, our goal is to organize the pet-related types into a Pets folder. If another set of types is added later, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"WildAnimals\"), \" for example, they're placed in the NewTypes folder alongside the Pets folder. The WildAnimals folder may contain types for animals that aren't pets, such as Squirrel and Rabbit types. In this way as types are added, the project remains well organized.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"/NewTypes\\n|__/src\\n   |__/NewTypes\\n      |__/Pets\\n         |__Dog.cs\\n         |__Cat.cs\\n      |__Program.cs\\n      |__NewTypes.csproj\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Dog.cs\"), \" could look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Pets\\n{\\n    public class Dog\\n    {\\n        public string TalkToOwner()\\n        {\\n            return \\\"Woof!\\\";\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"And \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cat.cs\"), \" something like this: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Pets\\n{\\n    public class Cat\\n    {\\n        public string TalkToOwner()\\n        {\\n            return \\\"Meow!\\\";\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Our \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Program.cs\"), \" looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// See https://aka.ms/new-console-template for more information\\nusing Pets;\\n\\nDog doggie = new Dog();\\nCat cattie = new Cat();\\nConsole.WriteLine(doggie.TalkToOwner());\\nConsole.WriteLine(cattie.TalkToOwner());\\n\")), mdx(\"p\", null, \"Our \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypes.csproj\"), \" contains the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\\n\\n  <PropertyGroup>\\n    <OutputType>Exe</OutputType>\\n    <TargetFramework>net6.0</TargetFramework>\\n    <ImplicitUsings>enable</ImplicitUsings>\\n    <Nullable>enable</Nullable>\\n  </PropertyGroup>\\n\\n</Project>\\n\")), mdx(\"h3\", {\n    \"id\": \"testing-the-sample\"\n  }, \"Testing the sample\"), mdx(\"p\", null, \"The NewTypes project is in place, and you've organized it by keeping the pets-related types in a folder. Let's put in some tests. In our exercises, we've used \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-dotnet-test\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"xUnit tests\")), \". Unit testing allows you to automatically check the behavior of your pet types to confirm that they're operating properly.\"), mdx(\"p\", null, \"We'll create our tests now a bit manually. Navigate back to the root folder and create a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"test\"), \" folder with a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest\"), \" folder within it. At a command prompt from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest\"), \" folder, execute \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet new xunit\"), \". This produces three files: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Usings.cs\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"NewTypeTest.csproj\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"UnitTest1.cs\"), \".\"), mdx(\"p\", null, \"The test project cannot currently test the types in NewTypes and requires a project reference to the NewTypes project. To add a project reference, use the dotnet add reference command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet add reference ../../src/NewTypes/NewTypes.csproj\\n\")), mdx(\"p\", null, \"If you get an error, or if you just want to do it manually, you can also add this to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest.csproj\"), \" yourself:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<ItemGroup>\\n  <ProjectReference Include=\\\"../../src/NewTypes/NewTypes.csproj\\\" />\\n</ItemGroup>\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \" On some devices, the slashes between folders need to be \\\"\\\\\\\" rather than \\\"/\\\". If you get an error after adding the Project Reference, try the other version of slash (just like below); \"), mdx(\"p\", null, \"Now our \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest.csproj\"), \" should look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\\n\\n  <PropertyGroup>\\n    <TargetFramework>net6.0</TargetFramework>\\n    <ImplicitUsings>enable</ImplicitUsings>\\n    <Nullable>enable</Nullable>\\n\\n    <IsPackable>false</IsPackable>\\n  </PropertyGroup>\\n\\n  <ItemGroup>\\n    <PackageReference Include=\\\"Microsoft.NET.Test.Sdk\\\" Version=\\\"17.1.0\\\" />\\n    <PackageReference Include=\\\"xunit\\\" Version=\\\"2.4.1\\\" />\\n    <PackageReference Include=\\\"xunit.runner.visualstudio\\\" Version=\\\"2.4.3\\\">\\n      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\\n      <PrivateAssets>all</PrivateAssets>\\n    </PackageReference>\\n    <PackageReference Include=\\\"coverlet.collector\\\" Version=\\\"3.1.2\\\">\\n      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\\n      <PrivateAssets>all</PrivateAssets>\\n    </PackageReference>\\n  </ItemGroup>\\n\\n  <ItemGroup>\\n    <ProjectReference Include=\\\"..\\\\..\\\\src\\\\NewTypes\\\\NewTypes.csproj\\\" />\\n  </ItemGroup>\\n\\n</Project>\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest.csproj\"), \" file contains the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Package reference to xunit, the xUnit testing framework\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Package reference to xunit.runner.visualstudio, so we can test with VSC\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Package reference to Microsoft.NET.Test.Sdk, the .NET testing infrastructure\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Project reference to \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NewTypes\"), \", the code to test\")), mdx(\"p\", null, \"There are also unnecessary parts for our basic testing. Remove the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"assets\"), \" for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"xunit.runner.visualstudio\"), \", as well as the whole \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"coverlet.collector\"), \". Your file should look like this, once you're done:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<Project Sdk=\\\"Microsoft.NET.Sdk\\\">\\n\\n  <PropertyGroup>\\n    <TargetFramework>net6.0</TargetFramework>\\n    <ImplicitUsings>enable</ImplicitUsings>\\n    <Nullable>enable</Nullable>\\n\\n    <IsPackable>false</IsPackable>\\n  </PropertyGroup>\\n\\n  <ItemGroup>\\n    <PackageReference Include=\\\"Microsoft.NET.Test.Sdk\\\" Version=\\\"17.1.0\\\" />\\n    <PackageReference Include=\\\"xunit\\\" Version=\\\"2.4.1\\\" />\\n    <PackageReference Include=\\\"xunit.runner.visualstudio\\\" Version=\\\"2.4.3\\\" />\\n  </ItemGroup>\\n\\n  <ItemGroup>\\n    <ProjectReference Include=\\\"..\\\\..\\\\src\\\\NewTypes\\\\NewTypes.csproj\\\" />\\n  </ItemGroup>\\n\\n</Project>\\n\")), mdx(\"p\", null, \"Change the name of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"UnitTest1.cs\"), \" to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PetTests.cs\"), \" and replace the code in the file with the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace NewTypeTest;\\n\\nusing Pets;\\n\\npublic class PetTests\\n{\\n    [Fact]\\n    public void DogTalkToOwnerReturnsWoof()\\n    {\\n        string expected = \\\"Woof!\\\";\\n        string actual = new Dog().TalkToOwner();\\n\\n        Assert.NotEqual(expected, actual);\\n    }\\n\\n    [Fact]\\n    public void CatTalkToOwnerReturnsMeow()\\n    {\\n        string expected = \\\"Meow!\\\";\\n        string actual = new Cat().TalkToOwner();\\n\\n        Assert.NotEqual(expected, actual);\\n    }\\n}\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The namespaces look a bit different than what we've used to, having semicolons rather than code blocks. This is a new feature.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Although you expect that the expected and actual values are equal, an initial assertion with the Assert.NotEqual check specifies that these values are not equal.\", mdx(\"p\", null, \"Always initially create a test to fail in order to check the logic of the test. After you confirm that the test fails, adjust the assertion to allow the test to pass. We'll get to testing just in a bit.\")), mdx(\"p\", null, \"The following shows the complete project structure:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"/NewTypes\\n|__/src\\n   |__/NewTypes\\n      |__/Pets\\n         |__Dog.cs\\n         |__Cat.cs\\n      |__Program.cs\\n      |__NewTypes.csproj\\n|__/test\\n   |__NewTypeTest\\n      |__PetTests.cs\\n      |__NewTypeTest.csproj\\n\")), mdx(\"p\", null, \"Run the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet test\"), \" command in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest\"), \" folder.\"), mdx(\"p\", null, \"As expected, testing fails, and the console displays the following output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Starting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n[xUnit.net 00:00:00.25]     PetTests.CatTalkToOwnerReturnsMeow [FAIL]\\n[xUnit.net 00:00:00.25]     PetTests.DogTalkToOwnerReturnsWoof [FAIL]\\n  Failed PetTests.CatTalkToOwnerReturnsMeow [3 ms]\\n  Error Message:\\n   Assert.NotEqual() Failure\\nExpected: Not \\\"Meow!\\\"\\nActual:   \\\"Meow!\\\"\\n  Stack Trace:\\n     at PetTests.CatTalkToOwnerReturnsMeow() in C:\\\\Users\\\\HeikkiHei\\\\Documents\\\\repos\\\\coding-exercises\\\\testproject\\\\test\\\\NewTypeTest\\\\PetTests.cs:line 22\\n  Failed PetTests.DogTalkToOwnerReturnsWoof [< 1 ms]\\n  Error Message:\\n   Assert.NotEqual() Failure\\nExpected: Not \\\"Woof!\\\"\\nActual:   \\\"Woof!\\\"\\n  Stack Trace:\\n     at PetTests.DogTalkToOwnerReturnsWoof() in C:\\\\Users\\\\HeikkiHei\\\\Documents\\\\repos\\\\coding-exercises\\\\testproject\\\\test\\\\NewTypeTest\\\\PetTests.cs:line 13\\n\\nFailed!  - Failed:     2, Passed:     0, Skipped:     0, Total:     2, Duration: 4 ms - NewTypeTest.dll (net6.0)\\n\")), mdx(\"p\", null, \"Change the assertions of your tests from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Assert.NotEqual\"), \" to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Assert.Equal\"), \" and rerun the tests with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet test\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Starting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n\\nPassed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 1 ms - NewTypeTest.dll (net6.0)\\n\")), mdx(\"p\", null, \"Now we have created a well organized project. We are able to run our tests and the project itself. You might have noticed, that we ran the commands \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet run\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet test\"), \" in different folders. That's because when we run the commands, we actually check the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \".csproj\"), \" file what we are running. \"), mdx(\"p\", null, \"The commands cannot now be run from the same folder as such, but require some parameters. For example, if we are at the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest\"), \" folder, we can run \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet test\"), \", plain and simple, as the file \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypeTest.csproj\"), \" is in that folder. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"/NewTypes\\n|__/src\\n   |__/NewTypes\\n      |__/Pets\\n         |__Dog.cs\\n         |__Cat.cs\\n      |__Program.cs\\n      |__NewTypes.csproj\\n|__/test\\n   |__NewTypeTest <-- WE ARE HERE\\n      |__PetTests.cs\\n      |__NewTypeTest.csproj\\n\")), mdx(\"p\", null, \"To run \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet run\"), \" from the same folder, we have to tell where the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypes.csproj\"), \" is located. To do this, we also have to give the option \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"-p\"), \", as in project, for the command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet test\\ndotnet run -p ../../src/NewTypes/NewTypes.csproj\\n\")), mdx(\"p\", null, \"On the other hand, we could be in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NewTypes\"), \" folder and be able to run the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dotnet run\"), \" as such.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"/NewTypes\\n|__/src\\n   |__/NewTypes <-- WE ARE HERE\\n      |__/Pets\\n         |__Dog.cs\\n         |__Cat.cs\\n      |__Program.cs\\n      |__NewTypes.csproj\\n|__/test\\n   |__NewTypeTest\\n      |__PetTests.cs\\n      |__NewTypeTest.csproj\\n\")), mdx(\"p\", null, \" The dotnet test requires some information.  We do not have the option of project now, just the path to project file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet run\\ndotnet test ../../test/NewTypeTest/NewTypeTest.csproj\\n\")), mdx(\"p\", null, \"This works in any folder of the project, as long as you remember to give the options correcty:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"/NewTypes <-- WE ARE HERE NOW\\n|__/src\\n   |__/NewTypes\\n      |__/Pets\\n         |__Dog.cs\\n         |__Cat.cs\\n      |__Program.cs\\n      |__NewTypes.csproj\\n|__/test\\n   |__NewTypeTest\\n      |__PetTests.cs\\n      |__NewTypeTest.csproj\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet run -p src/NewTypes/NewTypes.csproj\\ndotnet test test/NewTypeTest/NewTypeTest.csproj\\n\")), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"No exercises for this part, just plenty of crucial information.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#projects","title":"Projects","items":[{"url":"#creating-our-first-program","title":"Creating our first program"},{"url":"#organizing-and-testing-using-the-newtypes-pets-sample","title":"Organizing and testing using the NewTypes Pets Sample","items":[{"url":"#building-the-sample","title":"Building the sample"},{"url":"#testing-the-sample","title":"Testing the sample"}]}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Projects"}}},"pageContext":{"id":"a3398e19-ae1b-5f92-9d0f-2699398224a1"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
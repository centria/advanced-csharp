{"componentChunkName":"component---src-templates-docs-js","path":"/part07/part07-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Introduction to testing\",\n  \"nav_order\": 72,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"testing\"\n  }, \"Testing\"), mdx(\"p\", null, \"In previous section we took a very brief look into testing, but didn't really explain what we were doing. Let's take our first proper steps in the world of program testing.\"), mdx(\"h2\", {\n    \"id\": \"error-situations-and-step-by-step-problem-resolving\"\n  }, \"Error Situations and Step-By-Step Problem Resolving\"), mdx(\"p\", null, \"Errors end up in the programs that we write. Sometimes the errors are not serious and cause headache mostly to users of the program. Occasionally, however, mistakes can lead to very serious consequences. In any case, it's certain that a person learning to program makes many mistakes.\"), mdx(\"p\", null, \"You should never be afraid of or avoid making mistakes since that is the best way to learn. For this reason, try to break the program that you're working on from time to time to investigate error messages, and to see if those messages tell you something about the error(s) you've made.\"), mdx(\"p\", null, \"The report in the address \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://sunnyday.mit.edu/accidents/MCO_report.pdf\"\n  }, \"http://sunnyday.mit.edu/accidents/MCO_report.pdf\"), \" describes an incident resulting from a more serious software error and also the error itself.\"), mdx(\"p\", null, \"The bug in the software was caused by the fact that the program in question expected the programmer to use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/International_System_of_Units\"\n  }, \"International System of Units\"), \" (meters, kilograms, ...) in the calculations. However, the programmer had used the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/English_Engineering_units\"\n  }, \"American Measurement System\"), \" for some of the system's calculations, which prevented the satellite navigation auto-correction system from working as inteded.\"), mdx(\"p\", null, \"The satellite was destroyed.\"), mdx(\"p\", null, \"As programs grow in their complexity, finding errors becomes even more challenging. The debugger integrated into Visual Studio Code, and you can find clear instructions from here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://code.visualstudio.com/docs/editor/debugging\"\n  }, \"https://code.visualstudio.com/docs/editor/debugging\"), \".\"), mdx(\"h2\", {\n    \"id\": \"stack-trace\"\n  }, \"Stack Trace\"), mdx(\"p\", null, \"When an error occurs in a program, the program typically prints something called a stack trace, i.e., the list of method calls that resulted in the error. For example, a stack trace might look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Program.cs(13,46): error CS1002: ; expected [/mnt/c/Users/HeikkiHei/Documents/coding-exercises/project_examples/NewTypes/src/NewTypes/NewTypes.csproj]\\n\\nThe build failed. Fix the build errors and run again.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The erroring file is first, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Program.cs\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Then the location of the error, if possible \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"(on line 13, character 46)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The error code \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"CS1002\"), \", implicating what was the error\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Exact location of the file\")), mdx(\"p\", null, \"We got this trace bu removing a single semi-colon from our Pets-example.\"), mdx(\"h2\", {\n    \"id\": \"checklist-for-troubleshooting\"\n  }, \"Checklist for Troubleshooting\"), mdx(\"p\", null, \"If your code doesn't work and you don't know where the error is, these steps will help you get started.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Indent your code properly and find out if there are any missing parentheses.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Verify that the variables used are correctly named.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Test the program flow with different inputs and find out the sort of input that causes the program to not work as desired. If you received an error in the tests, the tests may also indicate the input used.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add print commands to the program in which you print out the values of the variables used at various stages of the program's execution.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Verify that all variables you are using are initialized. If they aren't, a NullPointerException error will occur.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If your program causes an exception, you should definitely pay attention to the stack trace associated with the exception, which is the list of method calls that resulted in the situation that caused the exception.\")), mdx(\"h2\", {\n    \"id\": \"passing-test-input-console\"\n  }, \"Passing Test Input Console\"), mdx(\"p\", null, \"Manually testing the program is often laborious. It's possible to automate the passing of input by, for example, creating a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.io.stringreader?view=netframework-4.8\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"StringReader\")), \" and giving that content to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.console.setin?view=netframework-4.8\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Console.SetIn\")), \". You'll find an example below of how to test a program automatically. The program first enters five strings, followed by the previously seen string. After that, we try to enter a new string. The string \\\"six\\\" should not appear in the word set.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing System.IO;\\nusing System.Collections.Generic;\\n\\n\\nnamespace Exercise001\\n{\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      string input = \\\"one\\\\n\\\" + \\\"two\\\\n\\\" +\\n                      \\\"three\\\\n\\\" + \\\"four\\\\n\\\" +\\n                      \\\"five\\\\n\\\" + \\\"one\\\\n\\\" +\\n                      \\\"six\\\\n\\\";\\n      StringReader reader = new StringReader(input);\\n\\n      List<string> read = new List<string>();\\n\\n      while (true)\\n      {\\n        Console.WriteLine(\\\"Enter an input: \\\");\\n        // Redirect the console input to the reader\\n        Console.SetIn(reader);\\n        // It is now in memory and will be given to the ReadLine\\n        // Every linebreak \\\"\\\\n\\\" starts a new line\\n        // giving the ReadLine six inputs\\n        string line = Console.ReadLine();\\n        if (read.Contains(line))\\n        {\\n          break;\\n        }\\n\\n        read.Add(line);\\n      }\\n\\n      Console.WriteLine(\\\"Thank you!\\\");\\n\\n      if (read.Contains(\\\"six\\\"))\\n      {\\n        Console.WriteLine(\\\"A value that should not have been added to the group was added to it.\\\");\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The program's output only shows the one provided by the program, and no user commands.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Enter an input:\\nEnter an input:\\nEnter an input:\\nEnter an input:\\nEnter an input:\\nEnter an input:\\nThank you!\\n\")), mdx(\"p\", null, \"Passing a string to the constructor of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"StringReader\"), \" class replaces input read from the keyboard. As such, the content of the string variable input 'simulates' user input. A line break in the input is marked with \\\\n. Therefore, each part ending in an newline character in a given string input corresponds to one input given to the ReadLine() command.\"), mdx(\"p\", null, \"When testing your program again manually, remove or comment out the line \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Console.SetIn(reader);\"), \". Alternatively, you can also change the test input, since we're dealing with a string.\"), mdx(\"h2\", {\n    \"id\": \"unit-testing\"\n  }, \"Unit Testing\"), mdx(\"p\", null, \"The automated testing method laid out above where the input to a program is modified is quite convenient, but limited nonetheless. Testing larger programs in this way is challenging. One solution to this is unit testing, where small parts of the program are tested in isolation.\"), mdx(\"p\", null, \"Unit testing refers to the testing of individual components in the source code, such as classes and their provided methods. The writing of tests revelas whether each class and method observs or deviates from the guideline of each method and class having a single, clear responsibility. The more responsibility the method has, the more complex the test. If a large application is written in a single method, writing tests for it becomes very challenging, if not impossible. Similarly, if the application is broken into clear classes and methods, then writing tests is straightforward.\"), mdx(\"p\", null, \"Ready-made unit test libraries are commonly used in writing tests, which provide methods and help classes for writing tests. One of the widely used testing libraries in C# is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://xunit.net/\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"xUnit\")), \", which has already been used in our exercises.\"), mdx(\"p\", null, \"Let's take a look at writing unit tests with the help of an example. Let's assume that we have the following Calculator class at our use, and want to write automated tests for it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Calculator\\n{\\n\\n  public int value { get; private set; }\\n\\n  public Calculator()\\n  {\\n    this.value = 0;\\n  }\\n\\n  public void Sum(int number)\\n  {\\n    this.value = this.value + number;\\n  }\\n\\n  public void Substract(int number)\\n  {\\n    this.value = this.value + number;\\n  }\\n}\\n\")), mdx(\"p\", null, \"The calculator works by always remembering the result produced by the preceding calculation. All subsequent calculations are always added to the previous result. A minor error resulting from copying and pasting has been left in the calculator above. The method substract should deduct from the value, but it currently adds to it.\"), mdx(\"p\", null, \"Unit test writing begins by creating a test class, which is created under the Test folder. When testing the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Calculator\"), \" class, the test class is to be called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CalculatorTests\"), \". \"), mdx(\"p\", null, \"The test class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CalculatorTest\"), \" is initially quite forgiving, as it does not infact test anything:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing Xunit;\\n\\nnamespace CalculatorTest\\n{\\n    public class UnitTest1\\n    {\\n        [Fact]\\n        public void Test1()\\n        {\\n\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Let's go through the file:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It belongs to the namespace CalculatorTest\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It has the class \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"UnitTest1\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Line\", \"[\", \"Fact\", \"]\", \" indicates that the following method is a test. \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"This line is required for dotnet test\"), \" to recognize the following method as a test.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The test method, now called Test1, is empty, and always passes.\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Remember to add the reference to the main project!\"), mdx(\"p\", null, \"Tests are methods of the test class where each test tests an individual unit. Let's begin testing the class -- we start off by creating a test method that confirms that the newly created calculator's value is intially 0.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing Xunit;\\nusing Calculators;\\n\\nnamespace CalculatorTest\\n{\\n    public class UnitTest1\\n    {\\n        [Fact]\\n        public void CalculatorInitialValueZero()\\n        {\\n            Calculator calculator = new Calculator();\\n            Assert.Equal(0, calculator.value);\\n        }\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet test \\n\\n[. . .]\\n\\nStarting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n\\nPassed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: < 1 ms\\n\")), mdx(\"p\", null, \"We also gave our test a more meaningful name.\"), mdx(\"p\", null, \"In the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CalculatorInitialValueZero\"), \" method a calculator object is first created. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Assert.Equal\"), \" method provided by the xUnit test framework is then used to check the value. The method is imported from the xUnit Framework with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using xUnit;\"), \", and it's given the expected value as a parameter - 0 in this instance - and the value returned by the calculator. If the values of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Assert.Equal\"), \" method values \\u200B\\u200Bdiffer, the test will not pass. Each test method should have an \\\"annotation\\\" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"[\", \"Fact\", \"]\"), \". This tells the xUnit test framework that this is an executable test method.\"), mdx(\"p\", null, \"Let's add functionality for summing and substacting to the test class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using Xunit;\\nusing Calculators;\\n\\nnamespace CalculatorTest\\n{\\n  public class Tests\\n  {\\n    [Fact]\\n    public void CalculatorInitialValueZero()\\n    {\\n      Calculator calculator = new Calculator();\\n      Assert.Equal(0, calculator.value);\\n    }\\n\\n    [Fact]\\n    public void ValueFiveWhenFiveAdded()\\n    {\\n      Calculator calculator = new Calculator();\\n      calculator.Sum(5);\\n      Assert.Equal(5, calculator.value);\\n    }\\n\\n    [Fact]\\n    public void ValueMinusTwoWhenTwoSubstracted()\\n    {\\n      Calculator calculator = new Calculator();\\n      calculator.Substract(2);\\n      Assert.Equal(-2, calculator.value);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Executing the tests produces the following output.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet test\\n\\nStarting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n[xUnit.net 00:00:00.37]     CalculatorTest.Tests.ValueMinusTwoWhenTwoSubstracted [FAIL]\\n  Failed CalculatorTest.Tests.ValueMinusTwoWhenTwoSubstracted [1 ms]\\n  Error Message:\\n   Assert.Equal() Failure\\nExpected: -2\\nActual:   2\\n  Stack Trace:\\n     at CalculatorTest.Tests.ValueMinusTwoWhenTwoSubstracted() in [. . .]Calculators/test/CalculatorTest/UnitTest1.cs:line 28\\n\\nFailed!  - Failed:     1, Passed:     2, Skipped:     0, Total:     3, Duration: 19 ms\\n\")), mdx(\"p\", null, \" The output tells us that three tests were executed. One of them failed. The test output also informs us of the line in which the error occured (28), and of the expected (-2) and actual (2) values. Whenever the execution of tests ends in an error, the testing framework also displays the error state visually.\"), mdx(\"p\", null, \" With the previous tests two passed, but one of them resulted in an error. Let's fix the mistake left in the Calculator class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// ...\\npublic void Substract(int number)\\n{\\n  this.value -= number;\\n}\\n// ...\\n\")), mdx(\"p\", null, \"When the test are run again, they pass.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet test \\n\\n[. . .]\\n\\nStarting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n\\nPassed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3, Duration: 2 ms\\n\")), mdx(\"p\", null, \"Unit testing tends to be extremely complicated if the whole application has been written in \\\"Main\\\". To make testing easier, the app should split into small parts, each having a clear responsibility. In the previous sections, we practiced this when we seperated the user interface from the application logic and created proper folder structure. Writing tests for parts of an application, such as the 'Pets' class from the previous section is significantly easier than writing them for program contained in \\\"Main\\\" in its entirety.\"), mdx(\"h2\", {\n    \"id\": \"test-driven-development\"\n  }, \"Test-Driven Development\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Test-driven_development\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Test-driven development\")), \" is a software development process that's based on constructing a piece of software in small iterations. In test-driven software development, the first thing a programmer always does is write an automatically-executable test, which tests a single piece of the computer program.\"), mdx(\"p\", null, \"The test will not pass because the functionality that satisfies the test, i.e., the part of the computer program to be examined, is missing. Once the test has been written, functionality that meets the test requirements is added to the program. The tests are run again. If all tests pass, a new test is added, or alternatively, if the tests fail, the already-written program is corrected. If necessary, the internal structure of the program will be corrected or refactored, so that the functionality of the program remains the same, but the structure becomes clearer.\"), mdx(\"p\", null, \"Test-driven software development consists of five steps that are repeated until the functionality of the program is complete.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Write a test. The programmer decides which program functionality to test and writes a test for it.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Run the tests and check if the tests pass. When a new test is written, the tests are run. If the test passes, the test is most likely erroneous and should be corrected - the test should only test functionality that hasn't yet been implemented.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Write the functionality that meets the test's requirements. The programmer implements functionality that only meets the test requirements. Note: this doesn't do things that the test does not require - functionality is only added in small increments.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Perform the tests. If the tests fail, there is likely to be an error in the functionality written. Correct the functionality - or, if there is no error in the functionality, fix the latest test that was performed.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Repair the internal structure of the program. As the size of the program increases, its internal structure is adjusted as needed. Methods that are too long are broken down into multiple parts and classes representing concepts are isolated. The tests are not modified, but are instead used to verify the correctness of the changes made to the program's internal structure - if a change in the program structure changes the functionality of the program, the tests will produce a warning and the programmer can remedy the situation.\"))), mdx(\"p\", null, \"You might notice, that this is actually the way our exercises have been done: The tests exist and expect you to create a program, which works as the tests require.\"), mdx(\"p\", null, \"Unit testing is only a part of software testing. On top of unit testing, a developer also performs integration tests that examine the interoperability of components, such as classes, and interface tests that test the application's interface through elements provided by the interface, such as buttons.\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"No exercises for this part\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#testing","title":"Testing","items":[{"url":"#error-situations-and-step-by-step-problem-resolving","title":"Error Situations and Step-By-Step Problem Resolving"},{"url":"#stack-trace","title":"Stack Trace"},{"url":"#checklist-for-troubleshooting","title":"Checklist for Troubleshooting"},{"url":"#passing-test-input-console","title":"Passing Test Input Console"},{"url":"#unit-testing","title":"Unit Testing"},{"url":"#test-driven-development","title":"Test-Driven Development"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Introduction to testing"}}},"pageContext":{"id":"41aeb461-82d7-5f62-aa4a-adb47d904755"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
{"componentChunkName":"component---src-templates-docs-js","path":"/part10/part10-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Handling strings\",\n  \"nav_order\": 102,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"stringbuilder-and-regular-expressions\"\n  }, \"StringBuilder and Regular Expressions\"), mdx(\"p\", null, \"We'll now take a look at some useful programming techniques and classes.\"), mdx(\"h2\", {\n    \"id\": \"stringbuilder\"\n  }, \"StringBuilder\"), mdx(\"p\", null, \"Let's look at the following program\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\";\\nfor (int i = 1; i < 5; i++)\\n{\\n  numbers = numbers + i;\\n}\\nConsole.WriteLine(numbers);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"1234\\n\")), mdx(\"p\", null, \"The program structure is straightforward. A string containing the number 1234 is created, and the string is then outputted.\"), mdx(\"p\", null, \"The program works, but there is a small problem invisible to the user. Calling \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"numbers + i\"), \" creates actually a new string. Let's inspect the program line-by-line with the repetition block unpacked.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\"; // creating a new string: \\\"\\\"\\nint i = 1;\\nnumbers = numbers + i; // creating a new string: \\\"1\\\"\\ni++;\\nnumbers = numbers + i; // creating a new string: \\\"12\\\"\\ni++;\\nnumbers = numbers + i; // creating a new string: \\\"123\\\"\\ni++;\\nnumbers = numbers + i; // creating a new string: \\\"1234\\\"\\ni++;\\n\\nConsole.WriteLine(numbers); // printing the string\\n\")), mdx(\"p\", null, \"In the previous example, five strings were created in total.\"), mdx(\"p\", null, \"Let's look at the same program where a new line is added after each number.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\";\\nfor (int i = 1; i < 5; i++)\\n{\\n  numbers = numbers + i + \\\"\\\\n\\\";\\n}\\nConsole.WriteLine(numbers);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"1\\n2\\n3\\n4\\n\")), mdx(\"p\", null, \"Each \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"+-operation\"), \" forms a new string. On the line numbers + i + \\\"\\\\n\\\"; a string is first created, after which another string is created joining a new line onto the previous string. Let's write this out as well.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\"; // creating a new string: \\\"\\\"\\nint i = 1;\\n// first creating the string \\\"1\\\" and then the string \\\"1\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\";\\ni++;\\n// first creating the string \\\"1\\\\n2\\\" and then the string \\\"1\\\\n2\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\"\\ni++;\\n// first creating the string \\\"1\\\\n2\\\\n3\\\" and then the string \\\"1\\\\n2\\\\n3\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\"\\ni++;\\n// first creating the string \\\"1\\\\n2\\\\n3\\\\n4\\\" and then the string \\\"1\\\\n2\\\\n3\\\\n4\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\"\\ni++;\\n\\nConsole.WriteLine(numbers); // printing the string\\n\")), mdx(\"p\", null, \"In the previous example, a total of nine strings is created.\"), mdx(\"p\", null, \"String creation - although unnoticeable at a small scale - is not a quick operation. Space is allocated in memory for each string where the string is then placed. If the string is only needed as part of creating a larger string, performance should be improved.\"), mdx(\"p\", null, \"C#'s ready-made \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"StringBuilder\"), \" from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Text\"), \" class provides a way to concatenate strings without the need to create them. A new StringBuilder object is created with a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"new StringBuilder()\"), \" call, and content is added to the object using the overloaded append method, i.e., there are variations of it for different types of variables. Finally, the StringBuilder object provides a string using the ToString method.\"), mdx(\"p\", null, \"In the example below, only one string is created.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  using System.Text;\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      StringBuilder numbers = new StringBuilder();\\n      for (int i = 1; i < 5; i++)\\n      {\\n        numbers.Append(i);\\n      }\\n      Console.WriteLine(numbers.ToString());\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Using StringBuilder is more performant that creating strings with the + operator.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \" We need the using System.Text; for the StringBuilder to work. \"), mdx(\"h2\", {\n    \"id\": \"regular-expressions\"\n  }, \"Regular expressions\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"regular expression\"), \" defines a set of strings in a compact form. Regular expressions are used, among other things, to verify the correctness of strings. We can assess the whether or not a string is in the desired form by a regular expression that defines the strings considered correct.\"), mdx(\"p\", null, \"Let's look at a problem where we need to check if a student number entered by the user is in the correct format. A student number (in my alma mater, Helsinki University) should begin with \\\"01\\\" followed by exactly 7 digits between 0\\u20139.\"), mdx(\"p\", null, \"You could verify the format of the student number, for instance, by going through the character string representing the student number using the string\", \"[\", \"index\", \"]\", \" method. Another way would be to check that the first character is \\\"0\\\" and call the Convert.ToInt32 method to convert the string to a number. You could then check that the number returned by the Convert.ToInt32 method is less than 20000000.\"), mdx(\"p\", null, \"Checking correctness with the help of regular expressions is done by first defining a suitable regular expression. We can then use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IsMatch\"), \" method of the Regex class, which checks whether the string contains the regular expression given as the regex constructor parameter. For the student number, the appropriate regular expression is \\\"^01\", \"[\", \"0-9\", \"]\", \"{7\", \"}\", \"$\\\", and checking the student number entered by a user is done as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  using System.Text.RegularExpressions;\\n\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      // Begins with 01\\n      // Contains only digits 0-9\\n      // exactly 7 of said digits\\n      // the string ends\\n      Regex regex = new Regex(\\\"^01[0-9]{7}$\\\");\\n      Console.Write(\\\"Provide a student number: \\\");\\n      string number = Console.ReadLine();\\n\\n      if (regex.IsMatch(number))\\n      {\\n        Console.WriteLine(\\\"Correct format.\\\");\\n      }\\n      else\\n      {\\n        Console.WriteLine(\\\"Incorrect format.\\\");\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"You might notice the regular expression starting with a circumflex and ending in a dollar sign. Let's get to that in a moment. First, let's go through the most common characters used in regular expressions.\"), mdx(\"h3\", {\n    \"id\": \"alternation-vertical-line\"\n  }, \"Alternation (Vertical Line)\"), mdx(\"p\", null, \"A vertical line indicates that parts of a regular expressions are optional. For example, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"00\", \"|\", \"111\", \"|\", \"0000\"), \" defines the strings 00,111 and 0000. The respond method returns true if the string matches any one of the specified group of alternatives.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"00|111|0000\\\");\\nstring str = \\\"00\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"The string contained one of the three alternatives\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The string contained none of the alternatives\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"The string contained one of the three alternatives\\n\")), mdx(\"p\", null, \"The regular expression \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"00\", \"|\", \"111\", \"|\", \"0000\"), \" is actually searching for a substring from a string. This would work as well:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"00|111|0000\\\");\\nstring str = \\\"1111111\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"The string contained one of the three alternatives\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The string contained none of the alternatives\\\");\\n}\\n\")), mdx(\"p\", null, \"Since \\\"1111\\\" contains a substring of \\\"111\\\", the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"regex.IsMatch\"), \" returns true.\"), mdx(\"h3\", {\n    \"id\": \"affecting-part-of-a-string-parentheses\"\n  }, \"Affecting Part of a String (Parentheses)\"), mdx(\"p\", null, \"You can use parentheses to determine which part of a regular expression is affected by the rules inside the parentheses. Say we want to allow the strings 00000 and 00001. We can do that by placing a vertical bar in between them this way 00000\", \"|\", \"00001. Parentheses allow us to limit the option to a specific part of the string. The expression 0000(0\", \"|\", \"1) specifies the strings 00000 and 00001.\"), mdx(\"p\", null, \"Similarly, the regular expression car(s) defines the singular (car) and plural (cars) forms of the word car. However, as we are searching for substrings with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IsMatch\"), \", also \\\"carssssss\\\" would return true.\"), mdx(\"h3\", {\n    \"id\": \"quantifiers\"\n  }, \"Quantifiers\"), mdx(\"p\", null, \"What is often desired is that a particular sub-string is repeated in a string. The following expressions are available in regular expressions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The quantifier \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"*\"), \" repeats 0 ... times, for example;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo)*$\\\");\\nstring str = \\\"trolololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The quantifier \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"+\"), \" repeats 1... times, for example;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo)+$\\\");\\nstring str = \\\"trolololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The quantifier \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"?\"), \" repeats 0 or 1 times, for example;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo)?$\\\");\\nstring str = \\\"trololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The quantifier \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"{a}\"), \" repeats a times, for example:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo){3}$\\\");\\nstring str = \\\"trololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The quantifier \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"{a,b}\"), \" repeats a ... b times, for example:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo){3,6}$\\\");\\nstring str = \\\"trololololololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Incorrect form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The quantifier \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"{a,}\"), \" repeats a ... times, for example:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo){3,}$\\\");\\nstring str = \\\"trololololololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"p\", null, \"You can use more than one quantifier in a single regular expression. For example, the regular expression ^5{3}(1\", \"|\", \"0)*5{3}$ defines strings that begin and end with three fives. An unlimited number of ones and zeros are allowed in between.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^5{3}(1|0)*5{3}$\\\");\\nstring str = \\\"5551101000011010555\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"h3\", {\n    \"id\": \"character-classes-square-brackets\"\n  }, \"Character Classes (Square Brackets)\"), mdx(\"p\", null, \"A character class can be used to specify a set of characters in a compact way. Characters are enclosed in square brackets, and a range is indicated with a dash. For example, \", \"[\", \"145\", \"]\", \" means \", \"(\", \"1\", \"|\", \"4\", \"|\", \"5\", \")\", \" and \", \"[\", \"2-36-9\", \"]\", \" means \", \"(\", \"2\", \"|\", \"3\", \"|\", \"6\", \"|\", \"7\", \"|\", \"8\", \"|\", \"9\", \")\", \". Similarly, the entry \", \"[\", \"a-c\", \"]\", \"*\", \" defines a regular expression that requires the string to contain only a, b and c.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"[145][2-36-9][a-c]*$\\\");\\nstring str = \\\"49acbc\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"h3\", {\n    \"id\": \"finding-exact-matches\"\n  }, \"Finding exact matches\"), mdx(\"p\", null, \"Our examples all started with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"^\"), \" and ended with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"$\"), \". These characters have special meanings in regular expressions.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"^\\t: Begin the match at the beginning of the line. Without this character in the beginning, we would search for the reqular expression substring from any part of the compared string.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"$\\t: End the match at the end of the line. Without this character, the rest of the string could be anything, and we would still get a match. With our string ending to a dollar sign, we make sure the string matches our regex exactly.\"))), mdx(\"h3\", {\n    \"id\": \"trying-out-regular-expressions\"\n  }, \"Trying out regular expressions\"), mdx(\"p\", null, \"Trying to find exact matches with regular expressions takes some practice. It is not ideal to rewrite our code again and again to check whether we have achieved the proper regular expression or not. Luckily, the internet has services to try out regular expressions, such as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.regextester.com/\"\n  }, \"https://www.regextester.com/\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://regex101.com/\"\n  }, \"https://regex101.com/\")), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '004 Regular Expression Checker',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"In the template is a class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Checker\"), \", which has three methods. Your task is to fill in the methods as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Section 1: Use regular expressions in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DayOfWeek(string str)\"), \", which returns true if the parameter string is an abbreviation of a day of the week (mon, tue, wed, thu, fri, sat, sun)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Section 2: Use regular expressions in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AllVowels(string str)\"), \", which returns true if all the letters in given string are wovels.\"))), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"For simplicity's sake, in this exercises the letters that are considered vowels are: a, e, i, o, and u. You don't have to take into account capital letters, but you can if you want to.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 3: Use regular expressions in \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"TimeOfDay(string str)\"), \"  to check whether the parameter string expresses a time of day in the form hh:mm:ss (hours, minutes, and seconds each always take up two spaces).\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The last one is tricky, and you might want to search the internet for answers.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Checker check = new Checker();\\n\\nConsole.WriteLine(check.DayOfWeek(\\\"tue\\\"));\\nConsole.WriteLine(check.DayOfWeek(\\\"tues\\\"));\\n\\nConsole.WriteLine(check.AllVowels(\\\"aeiouaaeeioiouoiaoueaiaeiou\\\"));\\nConsole.WriteLine(check.AllVowels(\\\"aeiouaaeeioiouoKiaoueaiaeiou\\\"));\\n\\nConsole.WriteLine(check.TimeOfDay(\\\"23:23:59\\\"));\\nConsole.WriteLine(check.TimeOfDay(\\\"00:00:60\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"True\\nFalse\\nTrue\\nFalse\\nTrue\\nFalse\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#stringbuilder-and-regular-expressions","title":"StringBuilder and Regular Expressions","items":[{"url":"#stringbuilder","title":"StringBuilder"},{"url":"#regular-expressions","title":"Regular expressions","items":[{"url":"#alternation-vertical-line","title":"Alternation (Vertical Line)"},{"url":"#affecting-part-of-a-string-parentheses","title":"Affecting Part of a String (Parentheses)"},{"url":"#quantifiers","title":"Quantifiers"},{"url":"#character-classes-square-brackets","title":"Character Classes (Square Brackets)"},{"url":"#finding-exact-matches","title":"Finding exact matches"},{"url":"#trying-out-regular-expressions","title":"Trying out regular expressions"}]}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Handling strings"}}},"pageContext":{"id":"af9f940a-2627-5947-b874-664497328782"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
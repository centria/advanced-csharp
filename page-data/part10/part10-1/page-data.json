{"componentChunkName":"component---src-templates-docs-js","path":"/part10/part10-1","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"IComparable Interface\",\n  \"nav_order\": 101,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"icomparable\"\n  }, \"IComparable\"), mdx(\"p\", null, \"In the previous section, we looked at interfaces in more general terms - let's now familiarize oruselves with one of C#'s ready interfaces. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.icomparable-1?view=net-5.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"IComparable interface\")), \" defines the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.icomparable-1.compareto?view=net-5.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"CompareTo\")), \" method used to compare objects. If a class implements the IComparable interface, objects created from that class can be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sort\"), \" using C#'s sorting algorithms.\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CompareTo\"), \" method required by the IComparable interface gets as its parameter the object to which the \\\"this\\\" object is compared. If the \\\"this\\\" object comes before the object received as a parameter in terms of sorting order, the method should return a negative number. If, on the other hand, if \\\"this\\\" object comes after the object received as a parameter, the method should return a positive number. Otherwise, 0 is returned. The sorting resulting from the CompareTo method is called natural ordering.\"), mdx(\"p\", null, \"Let's take a look at this with the help of a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Member\"), \" class that represents a child or youth who belongs to a club. Each club member has a name and height. The club members should go to eat in order of height, so the Member class should implement the IComparable interface. The IComparable interface takes as its type parameter the class that is the subject of the comparison. We'll use the same Member class as the type parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  // IComparable is in System\\n  using System;\\n  // Implement IComparable<Member>\\n  // Explicit comparison to Member, not other objects\\n  public class Member : IComparable<Member>\\n  {\\n    public string name { get; }\\n    public int height { get; }\\n\\n    // Basic constructor\\n    public Member(string name, int height)\\n    {\\n      this.name = name;\\n      this.height = height;\\n    }\\n\\n    // CompareTo Member\\n    // For this we implement IComparable<Member>\\n    // With just IComparable, we would compare objects\\n    // With CompareTo(object obj)\\n    public int CompareTo(Member member)\\n    {\\n      // If compared member is null, return 1\\n      // \\\"this\\\" comes after null\\n      if (member == null)\\n      {\\n        return 1;\\n      }\\n      // If height is equal, return 0\\n      // They are now equal in comparison\\n      if (this.height == member.height)\\n      {\\n        return 0;\\n      }\\n      // If this height is more\\n      // Return 1\\n      // \\\"this\\\" comes after compared member\\n      else if (this.height > member.height)\\n      {\\n        return 1;\\n      }\\n      // As all other options have been done\\n      // Return -1\\n      // \\\"this\\\" comes before compared member\\n      else\\n      {\\n        return -1;\\n      }\\n    }\\n\\n    // Basic ToString\\n    public override string ToString()\\n    {\\n      return this.name + \\\" (\\\" + this.height + \\\")\\\";\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The CompareTo method required by the interface returns an integer that informs us of the order of comparison.\"), mdx(\"p\", null, \"Since returning a negative number from the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CompareTo()\"), \" is enough if the this object is smaller than the parameter object, and zero when the heights are the same, the CompareTo method described above can also be implemented as follows.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public int CompareTo(Member member)\\n{\\n  return this.height - member.height;\\n}\\n\")), mdx(\"p\", null, \"Since the Member class now implements the IComparable interface, it is possible to sort a list of members by using the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sort\"), \" method. In fact, objects of any class that implements the IComparable interface can be sorted using the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sort\"), \" method. For example, strings and integers implement IComparable.\"), mdx(\"p\", null, \"Sorting club members is straightforward now.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// List of Members\\nList<Member> member = new List<Member>();\\n// Add three regular members\\nmember.Add(new Member(\\\"mikael\\\", 182));\\nmember.Add(new Member(\\\"matti\\\", 187));\\nmember.Add(new Member(\\\"ada\\\", 184));\\n// Add null to show the sorting of null\\nmember.Add(null);\\n\\n// Print each member\\nmember.ForEach(Console.WriteLine);\\n\\nConsole.WriteLine(\\\"Let's sort the members:\\\");\\n\\n// Sort the list\\nmember.Sort();\\n\\n// Print each member\\nmember.ForEach(Console.WriteLine);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"mikael (182)\\nmatti (187)\\nada (184)\\n\\nLet's sort the members:\\n\\nmikael (182)\\nada (184)\\nmatti (187)\\n\")), mdx(\"p\", null, \"A class can implement multiple interfaces. Multiple interfaces are implemented by separating the implemented interfaces with commas (public class ... : \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IFirstInterface\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ISecondInterface\"), \" ...). Implementing multiple interfaces requires us to implement all the of the methods whose implementations are required by the interfaces.\"), mdx(\"p\", null, \"Say we have the following \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IIdentifiable\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public interface IIdentifiable\\n{\\n    string socialSecurityNumber { get; }\\n}\\n\")), mdx(\"p\", null, \"We want to create a Person who is both identifiable and sortable. This can be achieved by implementing both of the interfaces. An example is provided below.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person : IIdentifiable, IComparable<Person>\\n{\\n    public string name { get; }\\n    public string socialSecurityNumber { get; }\\n\\n    public Person(string name, string socialSecurityNumber)\\n    {\\n        this.name = name;\\n        this.socialSecurityNumber = socialSecurityNumber;\\n    }\\n\\n    public int CompareTo(Person another)\\n    {\\n        return this.socialSecurityNumber.CompareTo(another.socialSecurityNumber);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Let us examine a situation, where we had bit of an erronous way of comparing items, i.e. by their name:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person : IIdentifiable, IComparable<Person> {\\n    public string name { get; }\\n    public string socialSecurityNumber { get; }\\n\\n    public Person(string name, string socialSecurityNumber) {\\n        this.name = name;\\n        this.socialSecurityNumber = socialSecurityNumber;\\n    }\\n\\n    public int CompareTo(Person another) {\\n        return this.name.CompareTo(another.name)\\n    }\\n}\\n\")), mdx(\"p\", null, \"This is not of course reasonable, as there are people with the same name. The logic is still quite repairable, as we could have a secondary comparison. If we want to stick as the name being the first sorting point and the socialSecurityNumber as secondary, we could do the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person : IIdentifiable, IComparable<Person> {\\n    public string name { get; }\\n    public string socialSecurityNumber { get; }\\n\\n    public Person(string name, string socialSecurityNumber) {\\n        this.name = name;\\n        this.socialSecurityNumber = socialSecurityNumber;\\n    }\\n\\n    public int CompareTo(Person another) {\\n      if (this.name == another.name)\\n      {\\n        return this.socialSecurityNumber.CompareTo(another.socialSecurityNumber);\\n      }\\n      return this.name.CompareTo(another.name);\\n    }\\n}\\n\")), mdx(\"p\", null, \"This way we can first check for the name equality and sort by name first, only after that by our socialSecurityNumber (in Finland that's also the birthday).\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '001 Wage Order',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"You are provided with the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Human\"), \". A human has a name and wage information. Implement the interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IComparable\"), \" in a way, that the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CompareTo\"), \"-method sorts the humans according to wage from biggest to smallest salary. The Program.cs already contains the following code for trying out your method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<Human> humans = new List<Human>();\\nhumans.Add(new Human(\\\"Merja\\\", 500));\\nhumans.Add(new Human(\\\"Pertti\\\", 80));\\nhumans.Add(new Human(\\\"Matti\\\", 150000));\\n\\n// Sorts the list when your CompareTo works\\n// Sort uses CompareTo internally\\nhumans.Sort();\\nhumans.ForEach(Console.WriteLine);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Matti 150000\\nMerja 500\\nPertti 80\\n\"))), mdx(Exercise, {\n    title: '002 Students in Alphabetical Order',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"The exercise template includes the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Student\"), \", which has a name. Implement the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IComprable\"), \"-interface in the Student-class in a way, that the CompareTo-method sorts the students in alphabetical order based on their names.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The name of the Student is a string, which implements Comparable itself. You may use it's CompareTo-method for your advantage when implementing the method for the Student-class. Note that string.CompareTo is case sensitive, but at this exercise, we don't have to worry about it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Student first = new Student(\\\"jamo\\\");\\nStudent second = new Student(\\\"jamo1\\\");\\n\\n// Should print -1\\nConsole.WriteLine(first.CompareTo(second));\\n\"))), mdx(Exercise, {\n    title: '003 Literacy Comparison',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Write a program that reads user input for books and their age recommendations.\"), mdx(\"p\", null, \"The program asks for new books until the user gives an empty string (only presses enter). After this, the program will print the amount and names of the books.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1\")), mdx(\"p\", null, \"Implement the reading and printing the books first in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextInterface\"), \", the ordering of them doesn't matter yet.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Input the name of the book, empty stops: \\n> The Ringing Lullaby Book \\nInput the age recommendation:\\n> 0\\nInput the name of the book, empty stops:\\n> The Exiting Transpotation Vehicles \\nInput the age recommendation:\\n> 0\\nInput the name of the book, empty stops:\\n> The Snowy Forest Calls \\nInput the age recommendation:\\n> 12\\nInput the name of the book, empty stops: \\n> Litmanen 10 \\nInput the age recommendation:\\n> 10\\nInput the name of the book, empty stops:\\n\\n4 books in total.\\n\\nBooks: \\nThe Ringing Lullaby Book (recommended for 0 year-olds or older) \\nThe Exiting Transpotation Vehicles (recommended for 0 year-olds or older) \\nThe Snowy Forest Calls (recommended for 12 year-olds or older) \\nLitmanen 10 (recommended for 10 year-olds or older)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2\")), mdx(\"p\", null, \"Expand your program so, that the books are sorted based on their age recommendations when they are printed. If two (or more) books share the same age recommendations the order between them does not matter. (i.e. create CompareTo in Book class)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Input the name of the book, empty stops: \\n> The Ringing Lullaby Book \\nInput the age recommendation:\\n> 0\\nInput the name of the book, empty stops:\\n> The Exiting Transpotation Vehicles \\nInput the age recommendation:\\n> 0\\nInput the name of the book, empty stops:\\n> The Snowy Forest Calls \\nInput the age recommendation:\\n> 12\\nInput the name of the book, empty stops: \\n> Litmanen 10 \\nInput the age recommendation:\\n> 10\\nInput the name of the book, empty stops:\\n\\n4 books in total.\\n\\nBooks: \\nThe Ringing Lullaby Book (recommended for 0 year-olds or older) \\nThe Exiting Transpotation Vehicles (recommended for 0 year-olds or older) \\nLitmanen 10 (recommended for 10 year-olds or older) \\nThe Snowy Forest Calls (recommended for 12 year-olds or older)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 3\")), mdx(\"p\", null, \"Expand your program, so that it sorts the books with the same age recommendation secondarily based on their name alphabetically. \"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"HINT! Use an if for the age recommendations!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Input the name of the book, empty stops: \\n> The Ringing Lullaby Book \\nInput the age recommendation:\\n> 0\\nInput the name of the book, empty stops:\\n> The Exiting Transpotation Vehicles \\nInput the age recommendation:\\n> 0\\nInput the name of the book, empty stops:\\n> The Snowy Forest Calls \\nInput the age recommendation:\\n> 12\\nInput the name of the book, empty stops: \\n> Litmanen 10 \\nInput the age recommendation:\\n> 10\\nInput the name of the book, empty stops:\\n\\n4 books in total.\\n\\nBooks: \\nThe Exiting Transpotation Vehicles (recommended for 0 year-olds or older) \\nThe Ringing Lullaby Book (recommended for 0 year-olds or older) \\nLitmanen 10 (recommended for 10 year-olds or older) \\nThe Snowy Forest Calls (recommended for 12 year-olds or older)\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#icomparable","title":"IComparable"},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"IComparable Interface"}}},"pageContext":{"id":"aea9b303-6762-5fdb-b5e6-c1af2faabcb1"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
{"componentChunkName":"component---src-templates-docs-js","path":"/part09/part09-3","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Polymorphism\",\n  \"nav_order\": 93,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"polymorphism\"\n  }, \"Polymorphism\"), mdx(\"p\", null, \"We've encountered situations where reference-type variables have other types besides their own one. For example, all objects are of type Object, i.e., any given object can be represented as a Object-type variable in addition to its own type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string text = \\\"text\\\";\\nObject textString = \\\"another string\\\";\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string text = \\\"text\\\";\\nObject textString = text;\\n\")), mdx(\"p\", null, \"In the examples above, a string variable is represented as both a String type and an Object type. Also, a String-type variable is assigned to an Object-type variable. However, assignment in the other direction, i.e., setting an Object-type variable to a String type, will not work. This is because Object-type variables are not of type String.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Object textString = \\\"another string\\\";\\nstring text = textString; // WON'T WORK!\\n\")), mdx(\"p\", null, \"What is this all about?\"), mdx(\"p\", null, \"In addition to each variable's original type, each variable can also be represented by the types of interfaces it implements and classes that it inherits. The String class inherits the Object class and, as such, String objects are always of type Object. The Object class does not inherit a String class, so Object-type variables are not automatically of type String. If we look at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netframework-4.8\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"API Documentation\")), \" for string, we can see that it inherits the Object class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Object --> String\\n\")), mdx(\"p\", null, \"The inheritance hierarchy lists all the classes that the given class has inherited. Inherited classes are listed in the order of inheritance, with class being inspected always at the bottom. In the inheritance hierarchy of the String class, we see that the String class inherits the Object class. In C#, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"each class can inherit one class at most\"), \". On the other hand, the inherited class may have inherited another class. As such, a class may indirectly inherit more than a single class.\"), mdx(\"p\", null, \"The inheritance hierarchy can also be thought of as a list of the different types that the class implements.\"), mdx(\"p\", null, \"Knowledge of the fact that objects can be of many different types -- of type Object, for instance -- makes programming simpler. If we only need methods defined in the Object class, such as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \" in a method, we can simply use Object as the type of the method parameter. In that case, you can pass the method \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" object as a parameter. Let's take a look at this with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PrintManyTimes\"), \" method. The method gets an Object-type variable and the number of print operations as its parameters.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void PrintManyTimes(Object obj, int times)\\n{\\n  int i = 0;\\n  while (i < times)\\n  {\\n    Console.WriteLine(obj.ToString());\\n\\n    i = i + 1;\\n  }\\n}\\n\")), mdx(\"p\", null, \"The method can be given any type of object as a parameter. Within the PrintManyTimes method, the object only has access to the methods defined in the Object class because the object is known in the method to be of type Object. The object may, in fact, be of another type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Printer printer = new Printer();\\n\\nstring str = \\\" o \\\";\\nList<string> words = new List<string>();\\nwords.Add(\\\"polymorphism\\\");\\nwords.Add(\\\"inheritance\\\");\\nwords.Add(\\\"encapsulation\\\");\\nwords.Add(\\\"abstraction\\\");\\n\\nprinter.PrintManyTimes(str, 2);\\nprinter.PrintManyTimes(words, 3);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \" o \\n o\\nSystem.Collections.Generic.List`1[System.String]\\nSystem.Collections.Generic.List`1[System.String]\\nSystem.Collections.Generic.List`1[System.String]\\n\")), mdx(\"p\", null, \"Let's continue to look at the API description of the String class. The inheritance hierarchy in the description is followed by a list of interfaces implemented by the class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"[System.Runtime.InteropServices.ComVisible(true)]\\n[System.Serializable]\\npublic sealed class String : ICloneable, IComparable, IComparable<string>, IConvertible, IEquatable<string>, System.Collections.Generic.IEnumerable<char>\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"String\"), \" class implements multiple interfaces, such as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IComparable\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IConvertible\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ICloneable\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"ICloneable cloneableString = \\\"string\\\";\\nIComparable comparableString = \\\"string\\\";\\nIConvertible convertibleString = \\\"string\\\";\\n\")), mdx(\"p\", null, \"Since we're able to define the type of a method's parameter, we can declare methods that receive an object that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"implements a specific interface\"), \". When a method's parameter is an interface, any object that implements that interface can be passed to it as an argument.\"), mdx(\"h2\", {\n    \"id\": \"implementing-multiple-abstract-classes-and-interfaces\"\n  }, \"Implementing multiple abstract classes and interfaces\"), mdx(\"p\", null, \"As stated earlier, a class can only inherit a single class directly, but can inherit an interface, or actually multiple interfaces, as well. How do we do that in code?\"), mdx(\"p\", null, \"The answer is simple, we just list them separated with a comma. For example a class from our exercises:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Cat : Animal, INoiseCapable\\n{\\n  // All the code a Cat needs\\n}\\n\")), mdx(\"p\", null, \"Now we have a class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cat\"), \", which implements the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"abstract class\"), \" called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Animal\"), \". At the same time, we also use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"interface\"), \" called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"INoiseCapable\"), \". \"), mdx(\"p\", null, \"Now you might also notice, why the capital \\\"I\\\" is very convenient in front of the interfaces: With it we can directly distinguish the difference between the two, and don't have to see their code to know, which is which.\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '008 Animals',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"In this exercise you'll demonstrate how to use both inheritance and interfaces.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"First implement an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"abstract class\"), \" called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Animal\"), \". The class should have a constructor that takes the animal's name as a parameter. The Animal class also has non-parameterized methods \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Eat\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sleep\"), \" that return nothing (void).\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The Sleep method should print \\\"(name) sleeps\\\", and the Eat method should print \\\"(name) eats\\\". Here (name) is the name of the animal in question.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Implement a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Dog\"), \" that inherits from Animal. Dog should have a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"parameterized constructor\"), \" that can be used to name it. The class should also have a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"non-parameterized constructor\"), \", which gives the dog the name \\\"Dog\\\". Another method that Dog must have is the non-parameterized \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bark\"), \", and it should not return any value (void). Like all animals, Dog needs to have the methods Eat and Sleep.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Next to implement is the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cat\"), \", that also inherits from the Animal class. Cat should have \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"two constructors\"), \": one with a parameter, used to name the cat according to the parameter, and one without parameters, in which case the name is simply \\\"Cat\\\". Another methd for Cat is a non-parameterized method called Purr that returns no value (void). Cats should be able to Eat and Sleep like in the first part.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Finally, create an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"interface\"), \" called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"INoiseCapable\"), \". It should define a non-parameterized method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MakeNoise\"), \" that returns no value (void). \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Implement the interface in the classes Dog and Cat\"), \". The interface should take use of the Bark and Purr methods you've defined earlier.\"))), mdx(\"p\", null, \"Below is an example of the expected functionality of all the parts.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dog dog = new Dog();\\ndog.Bark();\\ndog.Eat();\\ndog.Sleep();\\n\\nDog fido = new Dog(\\\"Fido\\\");\\nfido.Bark();\\n\\nCat cat = new Cat();\\ncat.Purr();\\ncat.Eat();\\ncat.Sleep();\\n\\nCat garfield = new Cat(\\\"Garfield\\\");\\ngarfield.Purr();\\n\\nINoiseCapable doggy = new Dog();\\ndoggy.MakeNoise();\\n\\nINoiseCapable catty = new Cat(\\\"Garfield\\\");\\ncatty.MakeNoise();\\n\\nCat c = (Cat) catty;\\nc.Purr();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Dog barks\\nDog eats\\nDog sleeps\\nFido barks\\nCat purrs\\nCat eats \\nCat sleeps\\nGarfield purrs\\nDog barks \\nGarfield purrs \\nGarfield purrs\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"This exercise is worth 2 points, and requires all the classes implemented to work\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#polymorphism","title":"Polymorphism","items":[{"url":"#implementing-multiple-abstract-classes-and-interfaces","title":"Implementing multiple abstract classes and interfaces"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Polymorphism"}}},"pageContext":{"id":"b0d43381-e902-550f-bb19-f88959faf8d9"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
{"componentChunkName":"component---src-templates-docs-js","path":"/part09/part09-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Interfaces\",\n  \"nav_order\": 92,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"interfaces\"\n  }, \"Interfaces\"), mdx(\"p\", null, \"We can use interfaces to define behavior that's required from a class, i.e., its methods. They're defined the same way that regular C# classes are, but \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\"public interface I...\\\"\"), \" is used instead of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\"public class ... \\\"\"), \" at the beginning of the class. Interfaces define behavior through method names and their return values. However, they don't always include the actual implementations of the methods. A visibility attribute on interfaces is not marked explicitly as they're always public. Let's examine a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" interface that describes readability.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public interface IReadable\\n  {\\n    string Read();\\n  }\\n}\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Notice how we started the name of the interface with a capital I? That's a naming convention for C#, and all the interfaces should start with one.\"), mdx(\"p\", null, \"The IReadable interface declares a Read() method, which returns a string-type object. IReadable defines certain behavior: for example, a text message or an email may be readable.\"), mdx(\"p\", null, \"The classes that implement the interface decide how the methods defined in the interface are implemented. A class implements the interface by adding the keyword implements after the class name followed by the name of the interface being implemented. Let's create a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextMessage\"), \" that implements the IReadable interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class TextMessage : IReadable\\n  {\\n    public string sender { get; }\\n    private string content;\\n\\n    public TextMessage(string sender, string content)\\n    {\\n      this.sender = sender;\\n      this.content = content;\\n    }\\n\\n    public string Read()\\n    {\\n      return this.content;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Since the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextMessage\"), \" class implements the Readable interface (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public class TextMessage : Readable\"), \"), the TextMessage class must contain an implementation of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public string Read()\"), \" method. Implementations of methods defined in the interface must always have public as their visibility attribute, and are public by default.\"), mdx(\"p\", null, \"When a class implements an interface, it signs an agreement. The agreement dictates that the class will implement the methods defined by the interface. If those methods are not implemented in the class, the program will not function.\"), mdx(\"p\", null, \"The interface defines only the names, parameters, and return values \\u200B\\u200Bof the required methods. The interface, however, does not have a say on the internal implementation of its methods. It is the responsibility of the programmer to define the internal functionality for the methods.\"), mdx(\"p\", null, \"In addition to the TextMessage class, let's add another class that implements the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" interface. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \" class is an electronic implementation of a book that containing the title and pages of a book. The ebook is read page by page, and calling the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public String read()\"), \" method always returns the next page as a string.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System.Collections.Generic;\\n  public class EBook : IReadable\\n  {\\n    public string name { get; }\\n    private List<string> pages;\\n    private int pageNumber;\\n\\n    public EBook(string name, List<string> pages)\\n    {\\n      this.name = name;\\n      this.pages = pages;\\n      this.pageNumber = 0;\\n    }\\n\\n    public int Pages()\\n    {\\n      return this.pages.Count;\\n    }\\n\\n    public string Read()\\n    {\\n      string page = this.pages[this.pageNumber];\\n      NextPage();\\n      return page;\\n    }\\n\\n    private void NextPage()\\n    {\\n      this.pageNumber = this.pageNumber + 1;\\n      if (this.pageNumber % this.pages.Count == 0)\\n      {\\n        this.pageNumber = 0;\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Objects can be instantiated from interface-implementing classes just like with normal classes. They're also used in the same way, for instance, as an List's type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TextMessage message = new TextMessage(\\\"teacher\\\", \\\"It's going great!\\\");\\nConsole.WriteLine(message.Read());\\n\\nList<TextMessage> txtmsg = new List<TextMessage>();\\ntxtmsg.Add(new TextMessage(\\\"private number\\\", \\\"I hid the body.\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"It's going great!\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<string> pages = new List<string>();\\npages.Add(\\\"Split your method into short, readable entities.\\\");\\npages.Add(\\\"Seperate the user-interface logic from the application logic.\\\");\\npages.Add(\\\"Always program a small part initially that solves a part of the problem.\\\");\\npages.Add(\\\"Practice makes the master. Try different out things for yourself and work on your own projects.\\\");\\n\\nEBook book = new EBook(\\\"Tips for programming.\\\", pages);\\n\\nint page = 0;\\nwhile (page < book.Pages())\\n{\\n  Console.WriteLine(book.Read());\\n  page = page + 1;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Split your method into short, readable entities.\\nSeperate the user-interface logic from the application logic.\\nAlways program a small part initially that solves a part of the problem.\\nPractice makes the master. Try different out things for yourself and work on your own projects.\\n\")), mdx(\"h2\", {\n    \"id\": \"interface-as-variable-type\"\n  }, \"Interface as Variable Type\"), mdx(\"p\", null, \"The type of a variable is always stated as its introduced. There are two kinds of type, the value-type variables (int, double, ...) and reference-type variables (all objects). We've so far used an object's class as the type of a reference-type variable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string str = \\\"string-object\\\";\\nTextMessage message = new TextMessage(\\\"teacher\\\", \\\"many types for the same object\\\");\\n\")), mdx(\"p\", null, \"An object's type can be other than its class. For example, the type of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \" class that implements the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" interface is both \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \". Similarly, the text message also has multiple types. Because the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextMessage\"), \" class implements the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" interface, it has a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" type in addition to the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextMessage\"), \" type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TextMessage message = new TextMessage(\\\"teacher\\\", \\\"Something cool's about to happen\\\");\\nIReadable readable = new TextMessage(\\\"teacher\\\", \\\"The text message is IReadable!\\\");\\n\")), mdx(\"p\", null, \"You cannot, however, do this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<string> pages = new List<string>();\\npages.Add(\\\"A method can call itself.\\\");\\n\\nIReadable book = new EBook(\\\"Introduction to Recursion\\\", pages);\\n\\nint page = 0;\\nwhile (page < book.Pages())\\n{\\n  Console.WriteLine(book.Read());\\n  page = page + 1;\\n} \\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Program.cs(16,26): error CS1061: 'IReadable' does not contain a definition for 'Pages' and no accessible extension method 'Pages' accepting a first argument of type 'IReadable' could be found (are you missing a using directive or an assembly reference?) [. . .]\\n\\nThe build failed. Fix the build errors and run again.\\n\")), mdx(\"p\", null, \"As the interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" does not have the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pages()\"), \" from the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \", the example above does not work. The inheritance of methods only goes one way... This would work:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<IReadable> readingList = new List<IReadable>();\\n\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"never been programming before...\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"gonna love it i think!\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"give me something more challenging! :)\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"you think i can do it?\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"up here we send several messages each day\\\"));\\n\\n\\nList<string> pages = new List<string>();\\npages.Add(\\\"A method can call itself.\\\");\\n\\nreadingList.Add(new EBook(\\\"Introduction to Recursion.\\\", pages));\\n\\nforeach (IReadable readable in readingList)\\n{\\n  Console.WriteLine(readable.Read());\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"never been programming before...\\ngonna love it i think!\\ngive me something more challenging! :)\\nyou think i can do it?\\nup here we send several messages each day\\nA method can call itself.\\n\")), mdx(\"p\", null, \"Note that although the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \" class that inherits the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" interface class is always of the interface's type, not all classes that implement the IReadable interface are of type EBook. You can assign an object created from the EBook class to a IReadable-type variable, but it does not work the other way without a separate type conversion.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"IReadable readable = new TextMessage(\\\"teacher\\\", \\\"TextMessage is Readable!\\\"); // works\\nTextMessage message = readable; // doesn't work\\n\\nTextMessage castMessage = (TextMessage)readable; // works if, and only if, readable is of text message type\\n\")), mdx(\"p\", null, \"Type conversion succeeds if, and only if, the variable is of the type that it's being converted to. Type conversion is not considered good practice, and one of the few situation where it's use is appropriate is in the implementation of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" method.\"), mdx(\"h2\", {\n    \"id\": \"interfaces-as-method-parameters\"\n  }, \"Interfaces as Method Parameters\"), mdx(\"p\", null, \"The true benefits of interfaces are reaped when they are used as the type of parameter provided to a method. Since an interface can be used as a variable's type, it can also be used as a parameter type in method calls. For example, the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Print\"), \" method in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Printer\"), \" class of the class below gets a variable of type read.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Printer\\n{\\n  public void Print(IReadable readable)\\n  {\\n    Console.WriteLine(readable.Read());\\n  }\\n}\\n\")), mdx(\"p\", null, \"The value of the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Print\"), \" method of the printer class lies in the fact that it can be given any class that implements the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" interface as a parameter. Were we to call the method with any object instantiate from a class that inherits the IReadable class, the method would function as desired.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TextMessage message = new TextMessage(\\\"ope\\\", \\\"Oh wow, this printer knows how to print these as well!\\\");\\n\\nList<string> pages = new List<string>();\\npages.Add(\\\"Values common to both {1, 3, 5} and {2, 3, 4, 5} are {3, 5}.\\\");\\nEbook book = new Ebook(\\\"Introduction to University Mathematics.\\\", pages);\\n\\nPrinter printer = new Printer();\\nprinter.Print(message);\\nprinter.Print(book);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Oh wow, this printer knows how to print these as well!\\nValues common to both {1, 3, 5} and {2, 3, 4, 5} are {3, 5}.\\n\")), mdx(\"p\", null, \"Let's make another class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \" to which we can ad interesting things to read. The class has a List instance as an instance variable, where the things to be read are added. Adding to the reading list is done using the add method, which receives a IReadable-type object as its parameter.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ReadingList\\n{\\n  private List<IReadable> readables;\\n\\n  public ReadingList()\\n  {\\n    this.readables = new List<IReadable>();\\n  }\\n\\n  public void Add(IReadable readable)\\n  {\\n    this.readables.Add(readable);\\n  }\\n\\n  public int ToRead()\\n  {\\n    return this.readables.Count;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Reading lists are usually readable, so let's have the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \" class implement the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" interface. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \" method of the reading list reads all the objects in the readables list, and adds them to the string returned by the Read() method one-by-one.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ReadingList : IReadable\\n{\\n  private List<IReadable> readables;\\n\\n  public ReadingList()\\n  {\\n    this.readables = new List<IReadable>();\\n  }\\n\\n  public void Add(IReadable readable)\\n  {\\n    this.readables.Add(readable);\\n  }\\n\\n  public int ToRead()\\n  {\\n    return this.readables.Count;\\n  }\\n\\n  public string Read()\\n  {\\n    string read = \\\"\\\";\\n\\n    foreach (IReadable readable in this.readables)\\n    {\\n      read = read + readable.Read() + \\\"\\\\n\\\";\\n    }\\n\\n    // once the reading list has been read, we empty it\\n    this.readables.Clear();\\n    return read;\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"ReadingList jonisList = new ReadingList();\\njonisList.Add(new TextMessage(\\\"heikki\\\", \\\"have you written the tests yet?\\\"));\\njonisList.Add(new TextMessage(\\\"heikki\\\", \\\"have you checked the submissions yet?\\\"));\\n\\nConsole.WriteLine(\\\"Joni's to-read: \\\" + jonisList.ToRead());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joni's to-read: 2\\n\")), mdx(\"p\", null, \"Because the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \" is of type \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \", we're able to add \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \" objects to the reading list. In the example below, Joni has a lot to read. Fortunately for him, Verna comes to the rescue and reads the messages on Joni's behalf.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"ReadingList jonisList = new ReadingList();\\nint i = 0;\\nwhile (i < 1000)\\n{\\n  jonisList.Add(new TextMessage(\\\"heikki\\\", \\\"did you test already?\\\"));\\n  i = i + 1;\\n}\\n\\nConsole.WriteLine(\\\"Joni's to-read: \\\" + jonisList.ToRead());\\nConsole.WriteLine(\\\"Delegating the reading to Verna\\\");\\n\\nReadingList vernasList = new ReadingList();\\nvernasList.Add(jonisList);\\nvernasList.Read();\\n\\nConsole.WriteLine();\\nConsole.WriteLine(\\\"Joni's to-read: \\\" + jonisList.ToRead());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joni's to-read: 1000\\nDelegating the reading to Verna\\n\\nJoni's to-read: 0\\n\")), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \" method called on Verna's list goes through all the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" objects and calls the Read method on them. When the Read method is called on Verna's list it also goes through Joni's reading list that's included in Verna's reading list. Joni's reading list is run through by calling its Read method. At the end of each Read method call, the read list is cleared. In this way, Joni's reading list empties when Verna reads it.\"), mdx(\"p\", null, \"As you notice, the program already contains a lot of references. It's a good idea to draw out the state of the program step-by-step on paper and outline how the read method call of the vernasList object proceeds!\"), mdx(\"h2\", {\n    \"id\": \"interface-as-a-return-type-of-a-method\"\n  }, \"Interface as a return type of a method\"), mdx(\"p\", null, \"Let's create some classes and an interface for our next example. Our interface, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \", dictates a method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Weight\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public interface IStorable\\n{\\n  double Weight();\\n}\\n\")), mdx(\"p\", null, \"Then we can have a couple of items, which implement the interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class CD : IStorable\\n{\\n  public string artist;\\n  public string name;\\n  public double weight;\\n  public int year;\\n  public CD(string artist, string name, int year)\\n  {\\n    this.artist = artist;\\n    this.name = name;\\n    this.weight = 0.1;\\n    this.year = year;\\n  }\\n\\n  public double Weight()\\n  {\\n    return this.weight;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.artist + \\\" - \\\" + this.name + \\\" (\\\" + this.year + \\\")\\\";\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Book : IStorable\\n{\\n  public string author;\\n  public string name;\\n  public double weight;\\n  public Book(string author, string name, double weight)\\n  {\\n    this.author = author;\\n    this.name = name;\\n    this.weight = weight;\\n  }\\n\\n  public double Weight()\\n  {\\n    return this.weight;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.author + \\\": \\\" + this.name;\\n  }\\n}\\n\")), mdx(\"p\", null, \"We could use them like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 2);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 1);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 0.5);\\n\\nCD cd1 = new CD(\\\"Pink Floyd\\\", \\\"Dark Side of the Moon\\\", 1973);\\nCD cd2 = new CD(\\\"Wigwam\\\", \\\"Nuclear Nightclub\\\", 1975);\\nCD cd3 = new CD(\\\"Rendezvous Park\\\", \\\"Closer to Being Here\\\", 2012);\\n\\nConsole.WriteLine(book1);\\nConsole.WriteLine(book2);\\nConsole.WriteLine(book3);\\nConsole.WriteLine(cd1);\\nConsole.WriteLine(cd2);\\nConsole.WriteLine(cd3);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Fedor Dostojevski: Crime and Punishment\\nRobert Martin: Clean Code\\nKent Beck: Test Driven Development\\nPink Floyd - Dark Side of the Moon (1973)\\nWigwam - Nuclear Nightclub (1975)\\nRendezvous Park - Closer to Being Here (2012)\\n\")), mdx(\"p\", null, \"But that's not very interesting, and we already know that. Let's do something more fun.\"), mdx(\"p\", null, \"Interfaces can be used as return types in methods -- just like any other \\\"regular\\\" variable types. In the next example is a class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Factory\"), \" that can be asked to construct differerent objects that implement the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Factory\\n{\\n\\n  public Factory()\\n  {\\n    // Note that there is no need to write an empy constructor without\\n    // paramatesr if the class doesn't have other constructors.\\n    // In these cases C# automatically creates a default constructor for\\n    // the class which is an empty constructor without parameters.\\n  }\\n\\n  public IStorable ProduceNew()\\n  {\\n    // The Random-object used here can be used to draw random numbers.\\n    Random ticket = new Random();\\n    // Draws a number from the range [0, 4[. The number will be 0, 1, 2, or 3.\\n    int number = ticket.Next(0, 4);\\n\\n    if (number == 0)\\n    {\\n      return new CD(\\\"Pink Floyd\\\", \\\"Dark Side of the Moon\\\", 1973);\\n    }\\n    else if (number == 1)\\n    {\\n      return new CD(\\\"Wigwam\\\", \\\"Nuclear Nightclub\\\", 1975);\\n    }\\n    else if (number == 2)\\n    {\\n      return new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 1);\\n    }\\n    else\\n    {\\n      return new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 0.7);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The Factory can be used without excatly knowing what differend kind of IStorable classes exist. In the next example there is a class Packer that gives a list of things. A packer knows a factory which is used to create the things:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Packer\\n{\\n  private Factory factory;\\n\\n  public Packer()\\n  {\\n    this.factory = new Factory();\\n  }\\n\\n  public List<IStorable> GiveAListOfThings()\\n  {\\n    List<IStorable> list = new List<IStorable>();\\n\\n    int i = 0;\\n    while (i < 10)\\n    {\\n      IStorable newThing = factory.ProduceNew();\\n      list.Add(newThing);\\n\\n      i = i + 1;\\n    }\\n\\n    return list;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Because the packer does not know the classes that implement the interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \", one can add new classes that impement the interface without changing the packer. The next example creates a new class that implements the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \" interface ChocolateBar. The factory has been changed so that it creates chocolate bars in addition to books and cds. The class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Packer\"), \" works without changes with the updated version of the factory.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ChocolateBar : IStorable\\n{\\n  // Because C#'s automatically generated default constructor is enough,\\n  // we don't need a constructor\\n\\n  public double Weight()\\n  {\\n    return 0.2;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return \\\"Candybar, weight: \\\" + Weight();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Factory\\n{\\n  public IStorable ProduceNew()\\n  {\\n    Random ticket = new Random();\\n    // increase the range by one\\n    int number = ticket.Next(0, 5);\\n\\n    if (number == 0)\\n    {\\n      return new CD(\\\"Pink Floyd\\\", \\\"Dark Side of the Moon\\\", 1973);\\n    }\\n    else if (number == 1)\\n    {\\n      return new CD(\\\"Wigwam\\\", \\\"Nuclear Nightclub\\\", 1975);\\n    }\\n    else if (number == 2)\\n    {\\n      return new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 1);\\n    }\\n    else if (number == 3)\\n    {\\n      return new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 0.7);\\n    }\\n    else\\n    {\\n      return new ChocolateBar();\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Using interfaces in programming enables reducing dependencies between classes. In the previous example the Packer does not depend on the classes that implement the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \" interface. Instead, it just depends on the interface. This makes possible to add new classes that implement the interface without changing the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Packer\"), \" class. What is more, adding new \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \" classes doesn't affect the classes that use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Packer\"), \" class.\"), mdx(\"p\", null, \"Our could works something like this now:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Packer packer = new Packer();\\n\\nforeach (IStorable item in packer.GiveAListOfThings())\\n{\\n  Console.WriteLine(item);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Kent Beck: Test Driven Development\\nPink Floyd - Dark Side of the Moon (1973)\\nPink Floyd - Dark Side of the Moon (1973)\\nWigwam - Nuclear Nightclub (1975)\\nPink Floyd - Dark Side of the Moon (1973)\\nWigwam - Nuclear Nightclub (1975)\\nCandybar, weight: 0.2\\nWigwam - Nuclear Nightclub (1975)\\nWigwam - Nuclear Nightclub (1975)\\nCandybar, weight: 0.2\\n\")), mdx(\"h2\", {\n    \"id\": \"interfaces-and-properties\"\n  }, \"Interfaces and properties\"), mdx(\"p\", null, \"So far, we have had only methods in our interfaces. What if we wanted to dictate properties? They work quite similarly as the methods, and for example our IStorable could be much cleaner with a property, rather than with a method. Let's take a look:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public interface IStorable\\n{\\n  double weight { get; set; }\\n}\\n\")), mdx(\"p\", null, \"As we now implement classes which are IStorable, they need to have a property of double weight, with get and set defined. Now our Book, for example, would look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Book : IStorable\\n{\\n  public string author;\\n  public string name;\\n  public double weight {get; set;}\\n  public Book(string author, string name, double weight)\\n  {\\n    this.author = author;\\n    this.name = name;\\n    this.weight = weight;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.author + \\\": \\\" + this.name;\\n  }\\n}\\n\")), mdx(\"p\", null, \"How do you know, which one to use in which case? This comes with practice. For example, our books are quite fine with just having the public property. But what if we needed a more complex weighing system? For example, we could have a container which holds only a certain amount of weight. In such a case, we would need some logic and a method could be justified.\"), mdx(\"h2\", {\n    \"id\": \"generic-interfaces-and-more-reading\"\n  }, \"Generic Interfaces and more reading.\"), mdx(\"p\", null, \"The C# offers multiple interfaces that are built-in, and we have actually used them. You can read more about them \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-interfaces\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"from here\")), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=net-5.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"even more from here\")), \". Both links lead to Microsoft documentation site, and give a glimpse on how some of the generic interfaces are implemented.\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Exercise, {\n    title: '005 Taco Boxes',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"In the exercise template you'll find \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Interface ITacoBox\"), \" ready for your use. It has the following methods:\"), mdx(\"p\", null, \"the method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int TacosRemaining()\"), \" return the number of tacos remaining in the box.\\nthe method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"void Eat()\"), \" reduces the number of tacos remaining by one. The number of tacos remaining can't become negative.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Implement the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TripleTacoBox\"), \", that implements the TacoBox interface. TripleTacobox has a constructor with no parameters. TripleTacobox has an object variable tacos which is initialized at 3 when the constructor is called.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Implement the class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CustomTacoBox\"), \", that implements the TacoBox interface. CustomTacoBox has a constructor with one parameter defining the initial number of tacos in the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CustomTacoBox(int tacos)\"), \".\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TripleTacoBox trip = new TripleTacoBox();\\nConsole.WriteLine(trip.TacosRemaining());\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\n// Try to Eat one too much\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\n\\nConsole.WriteLine();\\n\\nCustomTacoBox custom = new CustomTacoBox(2);\\nConsole.WriteLine(custom.TacosRemaining());\\ncustom.Eat();\\nConsole.WriteLine(custom.TacosRemaining());\\ncustom.Eat();\\nConsole.WriteLine(custom.TacosRemaining());\\n// Try to Eat one too much\\ncustom.Eat();\\nConsole.WriteLine(custom.TacosRemaining());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"3\\n2\\n1\\n0\\n0\\n\\n2\\n1\\n0\\n0\\n\"))), mdx(Exercise, {\n    title: '006 Interface in a Box',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Moving houses requires packing all your belongings into boxes. Let's imitate that with a program. The program will have boxes, and items to pack into those boxes. All items must implement the following Interface:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public interface IPackable {\\n    int Weight();\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1\")), mdx(\"p\", null, \"Create classes \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Book\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Furniture\"), \". Book has a constructor in which is given the author (string), name of the book (string) and the publication year (int). The weight of all books is 1 kg. Furniture has a constructor in which is given the type of furniture (string), color (string) and weight (int). Both of these should implement the interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IPackable\"), \". They also need a ToString each.\"), mdx(\"p\", null, \"The classes should work as following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 1866);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 2008);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 2000);\\n\\nFurniture sofa = new Furniture(\\\"Sofa\\\", \\\"Red\\\", 20);\\nFurniture bed = new Furniture(\\\"Twin bed\\\", \\\"White\\\", 15);\\nFurniture table = new Furniture(\\\"Dining room table\\\", \\\"Oak\\\", 30);\\n\\nList<IPackable> packages = new List<IPackable>();\\npackages.Add(book1);\\npackages.Add(book2);\\npackages.Add(book3);\\npackages.Add(sofa);\\npackages.Add(bed);\\npackages.Add(table);\\n\\npackages.ForEach(Console.WriteLine);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Fedor Dostojevski: Crime and Punishment (1866)\\nRobert Martin: Clean Code (2008)\\nKent Beck: Test Driven Development (2000)\\nRed Sofa - weight 20 kg\\nWhite Twin bed - weight 15 kg\\nOak Dining room table - weight 30 kg\\n\")), mdx(\"p\", null, \"Notice that the weight for books is not printed.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2\")), mdx(\"p\", null, \"Create a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Box\"), \".  Items implementing the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IPackable\"), \" interface can be packed into a box. The Box constructor takes the maximum capacity of the box in kilograms as a parameter. The combined weight of all items in a box cannot be more than the maximum capacity of the box. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Box should also implement IPackable\"), \", so you could have boxes inside boxes!\"), mdx(\"p\", null, \"Below is an example of using a box:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 1866);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 2008);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 2000);\\n\\nFurniture sofa = new Furniture(\\\"Sofa\\\", \\\"Red\\\", 20);\\nFurniture bed = new Furniture(\\\"Twin bed\\\", \\\"White\\\", 15);\\nFurniture table = new Furniture(\\\"Dining room table\\\", \\\"Oak\\\", 30);\\n\\nBox box = new Box(40);\\nbox.Add(book1);\\nbox.Add(book2);\\nbox.Add(book3);\\nbox.Add(sofa);\\nbox.Add(bed);\\nbox.Add(table);\\n\\nConsole.WriteLine(box);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"5 items, total weight 38 kg\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The table did not fit in the box, as the maximum capacity of the box is 40.\"), mdx(\"p\", null, \"Let's try some boxes inside boxes, as well:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 1866);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 2008);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 2000);\\n\\nFurniture sofa = new Furniture(\\\"Sofa\\\", \\\"Red\\\", 20);\\nFurniture bed = new Furniture(\\\"Twin bed\\\", \\\"White\\\", 15);\\nFurniture table = new Furniture(\\\"Dining room table\\\", \\\"Oak\\\", 30);\\n\\nBox bookBox = new Box(5);\\nbookBox.Add(book1);\\nbookBox.Add(book2);\\nbookBox.Add(book3);\\n\\nConsole.WriteLine(bookBox);\\nConsole.WriteLine();\\n\\nBox movingVan = new Box(800);\\nmovingVan.Add(bookBox);\\nmovingVan.Add(sofa);\\nmovingVan.Add(bed);\\nmovingVan.Add(table);\\n\\nConsole.WriteLine(movingVan);\\nConsole.WriteLine();\\n\\nBox shippingContainer = new Box(3000);\\nshippingContainer.Add(movingVan);\\n\\nConsole.WriteLine(shippingContainer);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"3 items, total weight 3 kg\\n\\n4 items, total weight 68 kg\\n\\n1 items, total weight 68 kg\\n\"))), mdx(Exercise, {\n    title: '007 Herds',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"In this exercise we are going to create organisms and herds of organisms that can move around. To represent the locations of the organisms we'll use a two-dimensional coordinate system. Each position involves two numbers: x and y coordinates. The x coordinate indicates how far from the (i.e. point zero, where x = 0, y = 0) that position is horizontally. The y coordinate indicates the distance from the origin vertically. If you are not familiar with using a coordinate system, you can study the basics from e.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Cartesian_coordinate_system\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Wikipedia\")), \".\"), mdx(\"p\", null, \"The exercise base includes the interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \", which represents something that can be moved from one position to another. The interface includes the method void move(int dx, int dy). The parameter dx tells how much the object moves on the x axis, and dy tells the distance on the y axis.\"), mdx(\"p\", null, \"This exercise consists of you implementing the classes \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Organism\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Herd\"), \", both of which are movable.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 1\")), mdx(\"p\", null, \"Create a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Organism\"), \" that implements the interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \". An organism should know its own location (as x, y coordinates). The API for the class Organism is to be as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public Organism(int x, int y)\")), mdx(\"p\", null, \"The class constructor that receives the x and y coordinates of the initial position as its parameters.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public override string ToString()\")), mdx(\"p\", null, \"Creates and returns a string representation of the organism. That representation should remind the following: \\\"x: 3; y: 6\\\". Notice that a semicolon is used to separate the coordinates.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void Move(int dx, int dy)\")), mdx(\"p\", null, \"Moves the object by the values it receives as parameters. The dx variable contains the change to coordinate x, and the dy variable ontains the change to the coordinate y. For example, if the value of dx is 5, the value of the object variable x should be incremented by five.\"), mdx(\"p\", null, \"Use the following code snippet to test the Organism class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Organism organism = new Organism(20, 30);\\nConsole.WriteLine(organism);\\norganism.Move(-10, 5);\\nConsole.WriteLine(organism);\\norganism.Move(50, 20);\\nConsole.WriteLine(organism);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"x: 20; y: 30 \\nx: 10; y: 35 \\nx: 60; y: 55\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Section 2\")), mdx(\"p\", null, \"Create a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Herd\"), \" that implements the interface \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \". A herd consists of multiple objects that implement the Movable interface. They must be stored in e.g. a list data structure.\"), mdx(\"p\", null, \"The Herd class must have the following API.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public override string ToString()\")), mdx(\"p\", null, \"Returns a string representation of the positions of the members of the herd, each on its own line.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void AddToHerd(IMovable movable)\")), mdx(\"p\", null, \"Adds an object that implements the Movable interface to the herd.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void Move(int dx, int dy)\")), mdx(\"p\", null, \"Moves the herd with by the amount specified by the parameters. Notice that here you have to move each member of the herd.\"), mdx(\"p\", null, \"Test out your program with the sample code below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Herd herd = new Herd();\\nherd.AddToHerd(new Organism(57, 66));\\nherd.AddToHerd(new Organism(73, 56));\\nherd.AddToHerd(new Organism(46, 52));\\nherd.AddToHerd(new Organism(19, 107));\\nConsole.WriteLine(herd);\\nherd.Move(2,2);\\nConsole.WriteLine(herd);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"x: 57; y: 66 \\nx: 73; y: 56 \\nx: 46; y: 52 \\nx: 19; y: 107\\n\\nx: 59; y: 68 \\nx: 75; y: 58 \\nx: 48; y: 54 \\nx: 21; y: 109\\n\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"The ToString of a herd might end in a line change, and that is totally fine!\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#interfaces","title":"Interfaces","items":[{"url":"#interface-as-variable-type","title":"Interface as Variable Type"},{"url":"#interfaces-as-method-parameters","title":"Interfaces as Method Parameters"},{"url":"#interface-as-a-return-type-of-a-method","title":"Interface as a return type of a method"},{"url":"#interfaces-and-properties","title":"Interfaces and properties"},{"url":"#generic-interfaces-and-more-reading","title":"Generic Interfaces and more reading."}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Interfaces"}}},"pageContext":{"id":"c4673f6e-52aa-584a-9325-1a72d9d39ead"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}
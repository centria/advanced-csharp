{"componentChunkName":"component---src-templates-docs-js","path":"/part12/part12-1","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Namespaces\",\n  \"nav_order\": 121,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We have used \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"namespaces\"), \" in our exercises and examples since the beginning of the course. But what are they, exactly?\"), mdx(\"p\", null, \"Namespaces have two main functions in C# programming. First, they are used to organize classes into coherent groups. Second, they are used to control the scope and visibility of class and method names in large programs.\"), mdx(\"h2\", {\n    \"id\": \"using-namespaces\"\n  }, \"Using namespaces\"), mdx(\"p\", null, \"The most common namespace so far, is the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System\"), \" namespace. In our programs, we call it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\n\")), mdx(\"p\", null, \"With this \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using directive\"), \" we tell our program, it should have access to the System namespace, and it can use classes, methods, and even nested namespaces, from System. For example, when we print in our code something to the console:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Console.WriteLine(\\\"text to be printed\\\");\\n\")), mdx(\"p\", null, \"We are actually calling:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"System.Console.WriteLine(\\\"text to be printed\\\");\\n\")), mdx(\"p\", null, \"With the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using System\"), \", we don't have to write the long form of the classes (Console) and methods (WriteLine) called, so we can keep our code cleaner and shorter. Or how do you feel, creating for example a list every time with...\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"System.Collections.Generic.List<string> list = new System.Colletions.Generic.List<string>();\\n\")), mdx(\"h2\", {\n    \"id\": \"scoping-with-namespaces\"\n  }, \"Scoping with namespaces\"), mdx(\"p\", null, \"The keyword \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"namespace\"), \" can be used to declare a scope for classes and methods within your project. This is crucial in especially large projects, but can be used to organize projects of any size. Let's look at an example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace OuterNamespace\\n{\\n  using System;\\n  class Example\\n  {\\n    public void ExampleMethod()\\n    {\\n      Console.WriteLine(\\\"ExampleMethod in OuterNamespace\\\");\\n    }\\n  }\\n\\n  // Create a nested namespace, and define another class.\\n  namespace InnerNamespace\\n  {\\n    class Example\\n    {\\n      public void ExampleMethod()\\n      {\\n        Console.WriteLine(\\\"ExampleMethod in InnerNamespace\\\");\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      // Displays \\\"ExampleMethod in OuterNamespace.\\\"\\n      OuterNamespace.Example outer = new OuterNamespace.Example();\\n      outer.ExampleMethod();\\n\\n      // Displays \\\"ExampleMethod in InnerNamespace.\\\"\\n      OuterNamespace.InnerNamespace.Example inner = new OuterNamespace.InnerNamespace.Example();\\n      inner.ExampleMethod();\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"What just happened?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"First, we create a namespace called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OuterNamespace\"), \". This namespace contains all the code in our example namespace.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We define \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using System\"), \" to be available for all the classes in that namespace. Even though we have nested namespaces and multiple classes, System is available for all of them.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"We define a class \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \", and for it a method \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ExampleMethod\"), \", which prints an informative text.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Next, we define \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"a namespace inside a namespace\"), \", or a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"nested namespace\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Inside this namespace we have a class called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \". As it is defined inside the nested namespace, it can have the same name, as the class in the outer namespace. In the class, we define a method to print information.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In our \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Main\"), \", we call our classes and their methods. Notice, that we are not using \\\"using\\\", but the long names of the namespaces. Also, the Main is in different namespace.\"))), mdx(\"p\", null, \"Let's move our Main to the same namespace as the classes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace OuterNamespace\\n{\\n\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      // Displays \\\"ExampleMethod in \\\"\\n      Example outer = new Example();\\n      outer.ExampleMethod();\\n\\n      // Displays \\\"ExampleMethod in InnerNamespace.\\\"\\n      InnerNamespace.Example inner = new InnerNamespace.Example();\\n      inner.ExampleMethod();\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"As you can see, the code is already quite much clearer, as the Main is now \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"in the same scope\"), \", or in the same namespace as the classes: The Main can \\\"see\\\" the classes and methods inside the OuterNamespace directly, as it is also part of it.\"), mdx(\"h2\", {\n    \"id\": \"hierarchy-and-fully-qualified-names\"\n  }, \"Hierarchy and fully qualified names\"), mdx(\"p\", null, \"Namespaces and Types have \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"fully qualified names\"), \", or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"unique title\"), \", which indicate the hierarchy of said items. In our example above, we use the statement \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OuterNamespace.InnerNamespace.Example\"), \". This shows us a hierarchy structure: \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"OuterNamespace\"), \" is the name of the outmost namespace (or type, this time namespace)\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"InnerNamespace\"), \" is the name of the second namespace (or type)\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Example\"), \" is nested inside the namespace above\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Etc, etc, etc...\")))))))), mdx(\"p\", null, \"So, with the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \".\"), \" (dot) we indicate a hierachy of items. Let's look at another example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Outmost     // Outmost\\n{\\n  class ExampleClass      // Outmost.ExampleClass\\n  {\\n    class ExampleInnerClass   // Outmost.ExampleClass.ExampleInnerClass\\n    {\\n    }\\n  }\\n  namespace Inner  // Outmost.Inner\\n  {\\n    class ExampleInnerClass   // Outmost.Inner.ExampleInnerClass\\n    {\\n    }\\n\\n    class ExampleOtherClass  // Outmost.Inner.ExampleOtherClass\\n    {\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"In the example above:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The namespace \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost\"), \" has a fully qualified name \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The namespace \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Inner\"), \" is a member of \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost\"), \", and has a fully qualified name \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost.Inner\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The class \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ExampleClass\"), \" is a member of \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost\"), \", and has fully qualified name \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost.ExampleClass\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The class name \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ExampleInnerClass\"), \" can be seen twice in our code. As they are declared in different unique locations, they have unique fully qualified names:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The first one is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost.ExampleClass.ExampleInnerClass\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The second one \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost.Inner.ExampleInnerClass\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Just like previously, we can of course have other classes in our namespaces as well. Here, we have the class \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ExampleOtherClass\"), \", with the fully qualified name \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Outmost.Inner.ExampleOtherClass\"), \".\")), mdx(\"p\", null, \"Just by looking at the fully qualified names, we can know if a type or a namespace is part of a larger whole, and how the structure above has been created.\"), mdx(\"h1\", {\n    \"id\": \"exercises\"\n  }, \"Exercises\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"All the exercises in this part are worth 2 points, without separate sections!\"), mdx(Exercise, {\n    title: '001 Namespace Examples',\n    mdxType: \"Exercise\"\n  }, mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In the exercise, you have a program with a ready Main, but the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NamespaceExample.cs\"), \" is missing namespaces.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Create two namespaces, one nested in another. You can find the namespaces by looking at the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"fully qualified names\"), \" of the method calls in Main.\")))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#using-namespaces","title":"Using namespaces"},{"url":"#scoping-with-namespaces","title":"Scoping with namespaces"},{"url":"#hierarchy-and-fully-qualified-names","title":"Hierarchy and fully qualified names"}]},{"url":"#exercises","title":"Exercises"}]},"frontmatter":{"title":"Namespaces"}}},"pageContext":{"id":"33bd85ee-4490-5f02-8707-773d900795b0"}},"staticQueryHashes":["1885717130","1950529541","2744905544","3020054368"]}